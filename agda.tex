% !TEX root = hazelnut-popl17.tex
So far, we have given an overview of the most important judgements and rules in
the semantics of Hazelnut, and stated the critical metatheorem, Sensibility, and several auxiliary ``checksum'' metatheorems. In a few
cases, we have informally sketched out why these metatheorems will hold. In order to formally establish that our design meets our stated objectives, we
have mechanized the semantics of Hazelnut using the Agda proof assistant \cite{norell:thesis}. We 
refer readers unfamiliar with Agda to the Agda Wiki, hosted
at \url{http://wiki.portal.chalmers.se/agda/}.

This development is available in the supplemental material. At the time of submission, the full set of rules is available and the proofs of Theorem \ref{thrm:actsafe}, Theorem \ref{lemma:movement-erasure} and a number of technical lemmas that we elided or mentioned informally in the text are complete. We also have nearly all of the cases of Reachability and Constructability complete, and we see no major barrier to the remaining cases -- we prioritized developing a clear exposition of our contributions after proving representative cases and finding that they were straightforward. The remaining cases will be completed in the repository linked in the non-anonymous supplementary material.\todo{include link to repos in non-anonymous supplementals}\todo{talk about determinism either here or there}

The documentation 
includes a more detailed discussion of the technical representation
decisions that we made. The main idea is standard: we encode each judgement as a
dependent type. The rules defining the judgements become the constructors of this
type, and derivations are terms of these type. This is a rich
setting that allows proofs to take advantage of pattern matching on the
shape of derivations, closely matching standard on-paper proofs. No proof automation was used, because the proof structure itself is likely to be interesting to researchers who plan to build upon our work. 
% The formalization differs from the calculus defined here in a few small 
% ways. Most interestingly, instead of giving separate movement rules for each 
% form of Z-expression, we abstract
% over different corresponding forms that happen to have the same arity, e.g. 
% additions and applications. Formalizing this intuition
% reduces the number of cases we need to consider 
% somewhat, but more importantly allows us to write a slightly more
% general calculus -- it will be easier to extend Hazelnut with more 
% interesting language features with this generic infrastructure in place.
We adopt Barendregt's convention for
bound variables \cite{urban}. Hazelnut's semantics does not need substitution, so we do not need to adopt more sophisticated encodings (e.g. \cite{lh09unibind,Pouillard11}.)
