
In this section, we enrich the core calculus of Hazelnut, initially
presented as consisting of arrow and a base type (numbers), which an
additional type constructor for (binary) \emph{sum types}, often
written~$\tau_1 + \tau_2$.
%
Below, we consider how this familiar language form impacts the
definitions of Hazelnut's core calculus.
%
In many cases, we show how the meta theory of Hazelnut forces our hand
in writing these definitions, ensuring that our rules adhere to the
broad goals associated with the meta theorems about sensibility,
determinism, constructability and reachability~(Sec.~\ref{sec:hazel}).

\paragraph{Extensions to Syntax.} 
%
As a reminder, the introduction forms for a sum type consists of
(tagged) \emph{injections}; here, we consider binary sums with first
and second injections~(we write~$\hinj{i}{\hexp}$, for
$i\in\{1,2\}$). The elimination form for a sum type consists of case
analysis~(we write~$\hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2}$).

Consistent with these new forms, below we extend our previous
syntantic forms for H-Types, H-Expressions, Z-Types, Z-Expressions and
Shapes.
%
In particular, in H-Types, Z-Types, and Shapes, we include syntax
below for the new type connective~$+$.
%
In H-Expressions, Z-Expressions and Shapes, we include term syntax
below for the type's introduction and elimination forms, injection and
case analysis, respectively.

%Extensions to \textbf{Syntax} for Sum Types:
%\\[2mm]
\begin{grammar}
\textsf{HTyp} & $\htau$ & \bnfas & $\cdots \bnfalt \tsum{\htau}{\htau}$
\\
\textsf{HExp} & $\hexp$ & \bnfas & $\cdots 
\bnfalt \hinj{i}{\hexp}
\bnfalt \hcase{\hexp}{x}{\hexp}{y}{\hexp}$
\\[2mm]
\textsf{ZTyp} & $\ztau$ & \bnfas & $\cdots \bnfalt \tsum{\ztau}{\htau} \bnfalt \tsum{\htau}{\ztau}$
\\
\textsf{ZExp} & $\zexp$ & \bnfas & $\cdots
\bnfalt \hinj{i}{\zexp}
\bnfalt \hcase{\zexp}{x}{\hexp}{y}{\hexp}$
\\
&& $\bnfalt$ & $\hcase{\hexp}{x}{\zexp}{y}{\hexp}
\bnfalt\hcase{\hexp}{x}{\hexp}{y}{\zexp}$
\\[2mm]
\textsf{Shape} & $\varphi$ & \bnfas & $\cdots \bnfalt \fsum \bnfalt \finj{i} \bnfalt \fcase{x}{y}$
\end{grammar}
%\\[2mm]

\paragraph{Extensions to Static Semantics.}
Figure~\ref{fig:sum-statics} extends the statics semantics of Hazelnut
with the static semantics of sum types.
%
First, we introduce the
relation~$\sumhasmatched{\htau}{\tsum{\htau_1}{\htau_2}}$ which is a
simple short-hand relation, analogous in spirit to the
relation~$\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$.  Each relation
allows typing and action rules to match type holes with the relevant
type constructor (when filled with holes).
%
Next, we extend the consistency relation~$\tcompat{\htau_1}{\htau_2}$,
with a covariant case for sum types.

Finally, we extend the analytical typing
judgement~$\hana{\hGamma}{\hexp}{\htau}$ with rules for introducing
and eliminating sum types.
%
In both the introduction and elimination rules, we use the ``has
matched'' relation $\sumhasmatched{\htau}{\tsum{\htau_1}{\htau_2}}$ to
permit the sum type~$\htau_+$ to be~$\hehole$, or a specific sum type
that uses the constructor~$\htau_1 + \htau_2$.
%
We adhere to the usual directionality for sum types in bidirectional
 systems: The introduction rule \emph{checks} the term against the sum
 type, whereas in the elimination rule, the scrutinee~$\hexp$
 synthesizes the sum type, and the branch arms are checked against a
 final return type~$\htau$.
%


\paragraph{Extensions to Action Semantics.}
Figures~\ref{fig:sum-action} and \ref{fig:sum-move} extends Hazelnut's
action-based editing rules for sum types.
%
Conceptually, these extensions consist of four parts: A rule for
constructing the new type connective~(Figure~\ref{fig:sum-action}
top), rules for constructing the introduction and elimination
forms~(Figure~\ref{fig:sum-action} middle), congruence rules for
editing sub-terms of these forms~(Figure \ref{fig:sum-action} bottom),
and rules for moving the cursor through the new type and term
forms~(Figure \ref{fig:sum-move}).  In Figure~\ref{fig:sum-move}, for
presentation we abuse notation by omitting the horizontal over-bars
that are typical of inference rules and by instead writing movement
action axioms in a table.
%
Below, we tour these extensions in further detail, and discuss design
constraints imposed by Hazelnut's meta theory.

\todo{talk about rules in more detail}

\begin{figure}
{
%Extensions to \textbf{Static Semantics} for Sum Types:
%\\[1mm]
\judgbox{\sumhasmatched{\htau}{\htau_1+\htau_2}}{$\htau$ has matched $\htau_1+\htau_2$}
\begin{mathpar}
\Infer{}{ }
{\sumhasmatched{\hehole}{\hehole + \hehole}}
\and
\Infer{}{ }
{\sumhasmatched{\htau_1 + \htau_2}{\htau_1 + \htau_2}}
\end{mathpar}

\judgbox{\tcompat{\htau_1}{\htau_2}}{(Additional type consistency form:)}
\begin{mathpar}
  \Infer{}{
    \tcompat{\htau_1}{\htau_1'} 
    \\
    \tcompat{\htau_2}{\htau_2'}
    }
   {\tcompat{\htau_1 + \htau_2}{\htau_1' + \htau_2'}}
\end{mathpar}

\judgbox{\hana{\hGamma}{\hexp}{\htau}}{(Additional analytical typing forms:)}
\begin{mathpar}
\Infer{Inj$_i$}
{ \hana{ \hGamma }{ \hexp }{ \htau_i }~~(i\in\{1,2\})
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
}
{ \hana{ \hGamma }{ \hinj{i}{\hexp} }{ \htau_{+} } }
\and
\Infer{Case}
{ \hsyn{ \hGamma }{ \hexp }{ \htau_{+} }
  \\
  \sumhasmatched{\htau_{+}}{\tsum{\htau_1}{\htau_2}}
  \\
  \hana{ \hGamma, x:\htau_1 }{ \hexp_1 }{ \htau }
  \\
  \hana{ \hGamma, y:\htau_2 }{ \hexp_2 }{ \htau }
}
{ \hana{ \hGamma }{ \hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2} }{ \htau } }
\end{mathpar}
\caption{Sum types: Static Semantics.}
\label{fig:sum-statics}
\vspace{5mm}
%Extensions to \textbf{Action Semantics} for Sum Types:
%\\[1mm]
\judgbox{\performTyp{\ztau}{\alpha}{\ztau}}{(Additional type construction action:)}
\begin{mathpar}
  \Infer{}{ }
{
  \performTyp{\zwsel{\htau}}{\aConstruct{\fsum}}
             {\tsum{{\htau}}{\zwsel{\hehole}}}
}
\end{mathpar}

\judgbox{\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}}
{(Additional analytical actions:)}
\begin{mathpar}
  \Infer{}{ \sumhasmatched{\htau}{\tsum{\hehole}{\hehole}} }
  {
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau_{+}}
              {\aConstruct{\finj{i}}}
              {\hinj{i}{\zwsel{\hehole}}}
  }
  \and
  \Infer{}{ \tincompat{\htau}{ \tsum{\hehole}{\hehole} } }
        {
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstruct{\finj{i}}}
              {\hhole{
                  \hinj{i}{\hehole}                  
                  : \zwsel{\hehole} + \hehole
              }}              
        }
  \and
  \Infer{}{ }{
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstruct{\fcase{x}{y}}}
              {\hcase{\zwsel{\hehole}}{x}{\hehole}{y}{\hehole}}
  }
\end{mathpar}

\begin{mathpar}
%% Inj -- Editing injected expression
\Infer{}
{
  \performAna{\hGamma}{\zexp}{\htau_i}{\alpha}{\zexp'}~~(i\in\{1,2\})
  \\
  \sumhasmatched{\htau_{+}}{\htau_1+\htau_2}
}{
  \performAna
  {\hGamma}
  {\hinj{i}{\zexp }}
  {\htau_{+}}
  {\alpha}
  {\hinj{i}{\zexp' }}
}
\and
%% Case -- Editing scrutinee
\Infer{}
{
  \hsyn
  {\hGamma}
  {\removeSel{\zexp}}
  {\htau_0}  
  \\
  \performSyn
  {\hGamma}
  {\zexp}
  {\htau_0}
  {\alpha}
  {\zexp'}
  {\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \hana{\hGamma, x:\htau_1}{\hexp_1}{\htau}
  \\
  \hana{\hGamma, y:\htau_2}{\hexp_2}{\htau}
}{
  \performAna
  {\hGamma}
  {\hcase{\zexp }{x}{\hexp_1}{y}{\hexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\zexp'}{x}{\hexp_1}{y}{\hexp_2}}
}
\and
%% Case -- Editing first branch arm
\Infer{}
{
  \hsyn{\hGamma}{\hexp}{\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \performAna{\hGamma, x:\htau_1}{\zexp_1}{\htau}{\alpha}{\zexp_1'}
  \\
  \hana{\hGamma, y:\htau_2}{\hexp_2}{\htau}
}{
  \performAna
  {\hGamma}
  {\hcase{\hexp}{x}{\zexp_1}{y}{\hexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\hexp}{x}{\zexp_1'}{y}{\hexp_2}}
}
\and
%% Case -- Editing second branch arm
\Infer{}
{
  \hsyn{\hGamma}{\hexp}{\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \hana{\hGamma, x:\htau_1}{\hexp_1}{\htau}
  \\
  \performAna{\hGamma, y:\htau_2}{\zexp_2}{\htau}{\alpha}{\zexp_2'}
}{
  \performAna
  {\hGamma}
  {\hcase{\hexp}{x}{\hexp_1}{y}{\zexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\hexp}{x}{\hexp_1}{y}{\zexp_2'}}
}

\end{mathpar}
}
\caption{Sum types: Actions (Construction \& Zipper Cases).}
\label{fig:sum-action}
\end{figure}

\begin{figure}
\judgbox{\performMove{\zexp}{\aMove{\delta}}{\zexp'}}{(Additional movement-action rules:)}
\begin{displaymath}
\begin{array}{@{}rcl}
  %\multicolumn{3}{l}{\textbf{Movement Actions for Sum Type Forms}:}
  %\\
  \TABperformMove
      {\zwsel{\tsum{\htau_1}{\htau_2}}}
      {\aMove{\dChild}}
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
  \\
  \TABperformMove
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
      {\aMove{\dNext}}
      {      {\tsum{{\htau_1}}{\zwsel{\htau_2}}}}
  \\
  \TABperformMove
      {      {\tsum{{\htau_1}}{\zwsel{\htau_2}}}}
      {\aMove{\dPrev}}
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
  \\
  \TABperformMove
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
      {\aMove{\dParent}}
      {\zwsel{\tsum{{\htau_1}}{{\htau_2}}}}
  \\
  \TABperformMove
      {      {\tsum{{\htau_1}}{{\zwsel{\htau_2}}}}}
      {\aMove{\dParent}}
      {\zwsel{\tsum{{\htau_1}}{\htau_2}}}
  \\[2mm]
  \TABperformMove
      {\zwsel{\hinj{i}{\hexp}}}
      {\aMove{\dChild}}
      {\hinj{i}{\zwsel{\hexp}}}      
  \\
  \TABperformMove
      {\hinj{i}{\zwsel{\hexp}}}      
      {\aMove{\dParent}}
      {\zwsel{\hinj{i}{\hexp}}}
  \\[2mm]
  \TABperformMove
      {\zwsel{\hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dChild}}
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dNext}}
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
      {\aMove{\dNext}}
      {      {\hcase{{\hexp}}{x}{{\hexp_1}}{y}{\zwsel{\hexp_2}}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{{\hexp_1}}{y}{\zwsel{\hexp_2}}}}
      {\aMove{\dPrev}}
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
      {\aMove{\dPrev}}
      {      {\hcase{{\zwsel{\hexp}}}{x}{{\hexp_1}}{y}{{\hexp_2}}}}
  \\
  \TABperformMove
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\hexp_1}{y}{\zwsel{\hexp_2}}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
\end{array}
\end{displaymath}
\caption{Movement action semantics for sum type forms.}
\label{fig:sum-move}
\end{figure}


\iffalse
\begin{displaymath}
\begin{array}{@{}r@{~}l@{~~~}c@{~~~}ll@{~~}}
  %\hline
  \multicolumn{5}{l}{\textbf{Type Construction Actions for Sum Type}:}
  \\
  %\hline
  %\hline
  %&\textbf{Pre} & \texttt{cons}. & \textbf{Post} & \textbf{Term type}
  %\\
  \TABperformTyp{\zwsel{\hehole}}{\aConstructx{\fsum}}
  {\tsum{\zwsel{\hehole}}{\hehole}}
  \\[3mm]
  %\hline
  \multicolumn{5}{l}{\textbf{Analytical Construction Actions for Sum Type}:}
  \\
  %\hline
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\tsum{\hehole}{\hehole}}
              {\aConstructx{\finj{i}}}
              {\hinj{i}{\zwsel{\hehole}}}
  \\
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\htau, \tincompat{\htau}{ \tsum{\hehole}{\hehole} }}
              {\aConstructx{\finj{i}}}
              {\hhole{\hinj{i}{\zwsel{\hehole}}}}
  \\
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstructx{\fcase{x}{y}}}
              {\hcase{\zwsel{\hehole}}{x}{\hehole}{y}{\hehole}}
  %\\[3mm]
  %\multicolumn{5}{l}{\textbf{Synthetic Construction Actions for $+$ Type}:}
  %\\
  %\multicolumn{5}{l}{\textit{none}}
  %\\[3mm]

  %\\[3mm]
  %\multicolumn{5}{l}{\textbf{Synthetic Construction Actions for $+$ Type}:}
\end{array}
\end{displaymath}
\fi
