% !TEX root = hazelnut-popl17.tex
The reader is encouraged to follow along with the examples that we will
discuss in this section using the implementation.

For concision, the right column in both Fig. \ref{ex1} and Fig \ref{ex2}
lists only the rules that describe the edit \emph{at the cursor}. This
omits both the rules needed to work down the tree structure of the
{Z-expression} to the cursor and the rules to propagate the change back
up. The missing rules are described in detail in
Sec. \ref{sec:zipper-cases}, and these examples are included in full in the
Agda mechanization described in Sec. \ref{sec:mech}.

\subsection{Example 1: Constructing the Increment Function}

Figure~\ref{fig:first-example} shows an edit sequence that constructs the
increment function, of type $\tarr{\tnum}{\tnum}$, starting from the empty
hole via the indicated sequence of {actions}. We will introduce Hazelnut's
formal syntax and define the referenced rules in
Sec. \ref{sec:hazel}. First, let us build some high-level intuitions.

The edit state in Hazelnut is a {Z-expression}, $\zexp$. Every Z-expression
has a single {H-expression}, $\hexp$, or {H-type}, $\htau$, under the
{cursor}, typeset $\zwsel{\hexp}$ or $\zwsel{\htau}$, respectively. For
example, on Line 1, the empty expression hole, $\hhole{}$, is under the
cursor.

Actions act relative to the cursor. The first action that we perform is
$\aConstruct{\flam{x}}$, which instantiates the hole with a lambda
abstraction binding the variable $x$. This results in the Z-expression on
Line 2, consisting of a lambda abstraction with an arrow type
ascription. The cursor is placed on the argument type hole. Type holes are
typeset like empty expression holes for visual consistency.

The actions on Lines 2-5 complete the type ascription. In particular, the
$\aConstruct{\fnum}$ action constructs the $\tnum$ type at the cursor and
composition of the $\aMove{\dParent}$ and $\aMove{\dChildn{2}}$ actions
move the cursor to the next hole.

\begin{figure}[t!]
  \label{ex1}
\begin{center}
$\arraycolsep=4px
\begin{array}{|r||l|l||l|l|}
\hline
\# & \textbf{Z-Expression} &
\textbf{Next Action} & \textbf{Rule}
\\
\hline
1 &
\zwsel{\hhole{}} &
\aConstruct{\flam{x}} &
\text{(\ref{r:conelamhole})}
\\ 2 &
\hlam{x}{\hhole{}} : \tarr{\zwsel{\hhole{}}}{\hhole{}} &
\aConstruct{\fnum{}} &
\text{(\ref{r:contnum})}
\\ 3 &
\hlam{x}{\hhole{}} : \tarr{\zwsel{\tnum{}}}{\hhole{}} &
\aMove{\dParent} &
\text{({\ref{rule:move-parent-arr-left}})}
\\ 4 &
\hlam{x}{\hhole{}} : \zwsel{\tarr{\tnum{}}{\hhole{}}} &
\aMove{\dChildn{2}} &
\text{({\ref{rule:move-arr-c2}})}
\\ 5 &
\hlam{x}{\hhole{}} : \tarr{\tnum}{\zwsel{\hhole{}}}
&
\aConstruct{\fnum{}} &
\text{(\ref{r:contnum})}
\\ 6 &
\hlam{x}{\hhole{}} : \tarr{\tnum{}}{\zwsel{\tnum{}}} &
\aMove{\dParent{}} &
\text{(\ref{rule:move-parent-arr-right})}
\\ 7 &
\hlam{x}{\hhole{}} : \zwsel{\tarr{\tnum{}}{\tnum{}}}
&
\aMove{\dParent{}} &
\text{(\ref{rule:move-parent-asc-right})}
\\ 8 &
\zwsel{\hlam{x}{\hhole{}} : \tarr{\tnum}{\tnum}} &
\aMove{\dChildn{1}} &
\text{(\ref{r:movefirstchild-asc})}
\\ 9 &
\zwsel{\hlam{x}{\hhole{}}} : \tarr{\tnum{}}{\tnum{}} &
\aMove{\dChildn{1}} &
\text{(\ref{r:movefirstchild-lam})}
\\ 10 &
\hlam{x}{\zwsel{\hhole{}}} : \tarr{\tnum{}}{\tnum{}} &
\aConstruct{\fvar{x}} &
\text{(\ref{r:conevar})}
\\ 11 &
\hlam{x}{\zwsel{{x}}} : \tarr{\tnum{}}{\tnum{}} &
{\aConstruct{\fplus}}
&
\text{(\ref{rule:construct-plus-compat})}
\\ 12 &
\hlam{x}{\hadd{x}{\zwsel{\hhole{}}}} : \tarr{\tnum{}}{\tnum{}} &
\aConstruct{\fnumlit{1}} &
\text{(\ref{r:conenumnum})}
\\ 13 &
\hlam{x}{\hadd{x}{\zwsel{\hnum{1}}}} : \tarr{\tnum}{\tnum} &
\textrm{---} &
{\textrm{---}}
\\ \hline
\end{array}
$\end{center}\vspace{-6px}
\caption{Constructing an increment function in Hazelnut.}
\label{fig:first-example}
\end{figure}

The actions on Lines 6-9 move the cursor to the function body. For
simplicity, Hazelnut defines only a small collection of primitive movement
actions. In practice, an editor would also define compound movement
actions, e.g. an action that moves the cursor directly to the next
remaining hole, in terms of these primitive movement actions.

Lines 10-12 complete the function body by first constructing the variable
$x$, then constructing the plus form, and finally constructing the number
$\hnum{1}$. Notice that we did not need to construct the function body in
an ``outside-in'' manner, i.e. we constructed $x$ before constructing the
outer plus form. Luckily, the transient function bodies, $x$ and $x +
\hhole{}$, could be checked against type $\tnum$ (as we will detail in
Sec. \ref{sec:holes}.)


\subsection{Example 2: Applying the Increment Function}

\begin{figure}[t!]
  \label{ex2}
\begin{center}
\colorbox{light-gray}{\hspace{53px} now assume $incr : \tarr{\tnum}{\tnum}$ \hspace{54px}}
$\arraycolsep=4px
\begin{array}{|r||l|l||l|l|}
\hline
\# & \textbf{Z-Expression} &
\textbf{Next Action} & \textbf{Rule}
\\
\hline
14 &
\zwsel{\hhole{}} &
\aConstruct{\fvar{incr}} \hphantom{~\,\,~~}&
\text{(\ref{r:conevar})}
\\ 15 &
\zwsel{incr} &
\aConstruct{\fap} &
\text{(\ref{r:coneapfn})}
\\ 16 &
incr(\zwsel{\hhole{}}) &
\aConstruct{\fvar{incr}} &
\text{(\ref{r:conevar2})}
\\ 17 &
incr(\hhole{\zwsel{incr}}) &
\aConstruct{\fap} &
\text{(\ref{r:coneapfn})}
\\ 18 &
incr(\hhole{incr(\zwsel{\hhole{}})}) \hphantom{~~~~} &
\aConstruct{\fnumlit{3}} &
\text{(\ref{r:conenumnum})}
\\ 19 &
incr(\hhole{incr(\zwsel{\hnum{3}})}) &
\aMove{\dParent}&
\text{(\ref{r:moveparent-ap2})}
\\ 20 &
incr(\hhole{\zwsel{incr(\hnum{3})}}) &
\aMove{\dParent} &
\text{(\ref{r:moveparent-hole})}
\\ 21 &
incr(\zwsel{\hhole{incr(\hnum{3})}})&
\aFinish &
\text{(\ref{r:finishana})}
\\ 22 &
incr(\zwsel{incr(\hnum{3})}) &
\textrm{---} &
{\textrm{---}}
\\ \hline
\end{array}
$\end{center}\vspace{-6px}
\caption{Appyling the increment function.}
\label{fig:second-example}
\end{figure}

Figure \ref{fig:second-example} shows an edit sequence that constructs the
expression $incr(incr(\hnum{3}))$, where $incr$ is assumed bound to the
increment function from Figure \ref{fig:first-example}.

We begin on Line 14 by constructing the variable $incr$. Line 15 then
constructs the application form with $incr$ in function position, leaving
the cursor on a hole in the argument position. Notice that we did not need
to construct the outer application form before identifying the function
being applied. Again, the transient edit state happens to be well-typed, so
we needed to make no special allowances for this order of actions.

We now need to apply $incr$ again, so we perform the same action on Line 16
as we did on Line 14, i.e. $\aConstruct{\fvar{incr}}$. In a syntactic
structure editor, performing such an action would result in the following
edit state:
\[
incr(\zwsel{incr})
\]
This edit state is ill-typed (after \emph{cursor erasure}): the argument of
$incr$ must be of type $\tnum$ but here it is of type
$\tarr{\tnum}{\tnum}$. Hazelnut cannot allow such an edit state to arise.

The programmer could alternatively have performed the $\aConstruct{\fap}$
action on Line 16. This would result in the following edit state, which is
well-typed according to the static semantics that we will define in the
next section:
\[
incr(\hhole{}(\zwsel{\hhole{}}))
\]
The problem is that the programmer is not able to identify the intended
function before constructing the function application form. This stands in
contrast to Lines 14-15.

Hazelnut's action semantics addresses this problem: rather than disallowing
the $\aConstruct{\fvar{incr}}$ action on Line 16, it leaves $incr$ inside a
hole:
\[
incr(\hhole{\zwsel{incr}})
\]
This defers the type consistency check, exactly as an empty hole in the
same position does. One way to think about non-empty holes is as an
internalization of the ``squiggly underline'' that text or syntactic
structure editors display to indicate a type inconsistency. By
internalizing this concept, the presence of a type inconsistency does not
leave the entire program formally meaningless.

The expression inside a non-empty hole must itself be well-typed, so the
programmer can continue to edit it. Lines 17-18 proceed to apply the inner
mention of $incr$ to a number literal, $\hnum{3}$. Finally, Lines 18-19
move the cursor to the non-empty hole and Line 21 performs the $\aFinish$
action. The $\aFinish$ action removes the hole if the type of the
expression inside the hole is consistent with the expected type, as it now
is. This results in the final edit state on Line 22, as desired. In
practice, the editor might automatically perform the $\aFinish$ action as
soon as it becomes possible, but for simplicity, Hazelnut formally requires
that it be performed explicitly.
