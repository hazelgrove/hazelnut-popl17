% !TEX root = hazelnut-popl17.tex

The previous section introduced Hazelnut by example. In this section, we systematically introduce the following  structures:
\begin{itemize}[itemsep=0px,partopsep=2px,topsep=2px]
\item \textbf{H-types} and \textbf{H-expressions} (Sec. \ref{sec:holes}), which are types and expressions with {holes}. H-types classify H-expressions according to Hazelnut's \textbf{bidirectional static semantics}.
\item \textbf{Z-types} and \textbf{Z-expressions} (Sec. \ref{sec:cursors}), which superimpose\- a \emph{cursor} onto H-types and H-expressions, respectively (following Huet's \emph{zipper pattern} \cite{JFP::Huet1997}.) Every Z-type (resp. Z-expression) corresponds to an H-type (resp. H-expression) by \emph{cursor erasure}.
\item \textbf{Actions} (Sec. \ref{sec:actions}), which act relative to the cursor according to Hazelnut's \textbf{bidirectional action semantics}. The action semantics enjoys a rich metatheory. Of particular note, the \emph{sensibility theorem} establishes that every edit state is well-typed after cursor erasure.
\end{itemize}

Our overview below omits certain ``uninteresting'' details. The supplement includes the complete collection of rules, in definitional order. These rules, along with the proofs of two key metatheorems, have been mechanized in Agda \cite{norell:thesis}, also in the supplement. We will summarize this effort in Sec. \ref{sec:mech}.% The supplement contains the Agda sources and additional technical details.

\subsection{H-types and H-expressions}\label{sec:holes}


Figure \ref{fig:hexp-syntax} defines the syntax of H-types, $\htau$, and H-expressions, $\hexp$. Most forms correspond directly to those of the simply typed lambda calculus (STLC) extended with a single base type, $\tnum$, of numbers (cf. \cite{pfpl}.) The number expression corresponding to the mathematical number $n$ is drawn $\hnum{n}$, and for simplicity, we define only a single arithmetic operation, $\hadd{\hexp}{\hexp}$. The form $\hexp : \htau$ is an explicit \emph{type ascription}. 

In addition to these standard forms, \emph{type holes} and \emph{empty expression holes} are both drawn $\hehole$ and \emph{non-empty expression holes} are drawn $\hhole{\hexp}$. We do not need non-empty type holes because every H-type is a valid classifier of H-expressions. 

Types and expressions that contain no holes are \emph{complete types} and \emph{complete expressions}, respectively. Formally, we can derive $\hcomplete{\htau}$ when $\htau$ is complete, and $\hcomplete{\hexp}$ when $\hexp$ is complete (see supplement.) We are not concerned here with defining a dynamic semantics for Hazelnut, but the dynamics for complete H-expressions would be entirely standard (in Sec. \ref{sec:rw} we discuss the multi-dimensional design space around the question of evaluating incomplete H-expressions.)% The complete types and expressions correspond immediately to the types and expressions of the STLC with numbers. %Holes mark subterms that are, notionally, ``under construction.'' We will see what this formally corresponds to in a moment.

\begin{figure}[t]
$\arraycolsep=4pt\begin{array}{lllllll}
\mathsf{HTyp} & \htau & ::= &
  \tarr{\htau}{\htau} ~\vert~
  \tnum ~\vert~
  \tehole\\
\mathsf{HExp} & \hexp & ::= &
  \hexp : \htau ~\vert~
  x ~\vert~
  \hlam{x}{\hexp} ~\vert~
  \hap{\hexp}{\hexp} ~\vert~
  \hnum{n} ~\vert~
  \hadd{\hexp}{\hexp} ~\vert~
  \hehole ~\vert~
  \hhole{\hexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of H-types and H-expressions. Metavariable $x$ ranges over variables and $n$ ranges over numerals.}
\label{fig:hexp-syntax}
\end{figure}
\begin{figure}
\noindent\fbox{$\tcompat{\htau}{\htau'}$}~~\text{$\tau$ and $\tau'$ are consistent}
% \begin{subequations}%\label{rules:tcompat}
% \begin{equation}%\label{rule:tcompat-comm}
% \inferrule
% %[TCSym]
% {
%   \tcompat{\htau}{\htau'}
% }{
%   \tcompat{\htau'}{\htau}
% }
% \end{equation}
\begin{mathpar}
\inferrule{ }{
  \tcompat{\tehole}{\htau}
}

% \end{equation}
% \begin{equation}%\label{rule:tcompat-hole}
\inferrule{ }{
  \tcompat{\htau}{\tehole}
}

\inferrule{ }{
  \tcompat{\htau}{\htau}
}

\inferrule{
  \tcompat{\htau_1}{\htau_1'}\\
  \tcompat{\htau_2}{\htau_2'}
}{
  \tcompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
}
\end{mathpar}
% \begin{equation}%\label{rule:tcompat-num}
% \end{equation}
% \begin{equation}%\label{rule:tcompat-arr}
% \end{equation}
% \end{subequations}
\fbox{$\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$}~~\text{$\tau$ has matched arrow type $\tarr{\htau_1}{\htau_2}$}
\begin{mathpar}
% \begin{subequations}
% \begin{equation}
\inferrule{ }{
  \arrmatch{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1}{\htau_2}}
}

% \end{equation}
% \begin{equation}
\inferrule{ }{
  \arrmatch{\tehole}{\tarr{\tehole}{\tehole}}
}
% \end{equation}
% \end{subequations}
\end{mathpar}
% \noindent\fbox{$\tincompat{\htau}{\htau'}$}
% \begin{subequations}
%   % \begin{equation}
%   %   \inferrule{
%   %     \tincompat{\htau}{\htau'}
%   %   }{
%   %     \tincompat{\htau'}{\htau}
%   %   }
%   % \end{equation}
%   \begin{equation}
%     \inferrule{ }{
%       \tincompat{\tarr{\htau_1}{\htau_2}}{\tnum}
%     }
%   \end{equation}
%   \begin{equation}
%     \inferrule{ }{
%       \tincompat{\tnum}{\tarr{\htau_1}{\htau_2}}
%     }
%   \end{equation}
%   \begin{equation}
%     \inferrule{
%       \tincompat{\htau_1}{\htau_1'}
%     }{
%       \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
%     }
%   \end{equation}
%   \begin{equation}
%     \inferrule{
%       \tincompat{\htau_2}{\htau_2'}
%     }{
%       \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
%     }
%   \end{equation}
% \end{subequations}
\caption{H-type consistency and matched arrow types.}
\label{fig:type-consistency}
\end{figure}

\begin{figure}
\fbox{$\hana{\hGamma}{\hexp}{\htau}$}~~\text{$\hexp$ analyzes against $\htau$}
\begin{subequations}
\begin{equation}\label{rule:ana-subsume}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau'}\\
  \tcompat{\htau}{\htau'}
}{
  \hana{\hGamma}{\hexp}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-lam}
\inferrule{
  \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}\\
  \hana{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\htau}
}
\end{equation}
\end{subequations}
\fbox{$\hsyn{\hGamma}{\hexp}{\htau}$}~~\text{$\hexp$ synthesizes $\htau$}
\begin{subequations}
\begin{equation}\label{rule:syn-asc}
\inferrule{
  \hana{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hexp : \htau}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-var}
\inferrule{ }{
  \hsyn{\hGamma, x : \htau}{x}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-ap}
\inferrule{
  \hsyn{\hGamma}{\hexp_1}{\htau}\\
  \arrmatch{\htau}{\tarr{\htau_2}{\htau'}}\\
  \hana{\hGamma}{\hexp_2}{\htau_2}
}{
  \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\htau'}
}
\end{equation}
\begin{equation}\label{rule:syn-num}
\inferrule{ }{
  \hsyn{\hGamma}{\hnum{n}}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:syn-plus}
\inferrule{
  \hana{\hGamma}{\hexp_1}{\tnum}\\
  \hana{\hGamma}{\hexp_2}{\tnum}
}{
  \hsyn{\hGamma}{\hadd{\hexp_1}{\hexp_2}}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:syn-ehole}
\inferrule{ }{
  \hsyn{\hGamma}{\hehole}{\tehole}
}
\end{equation}
\begin{equation}\label{rule:syn-hole}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hhole{\hexp}}{\tehole}
}
\end{equation}
\end{subequations}
\caption{Analysis and synthesis.}
\label{fig:ana-syn}
\end{figure}

Hazelnut's static semantics is organized as a \emph{bidirectional type system} \cite{Pierce:2000:LTI:345099.345100,bidi-tutorial} around the two mutually defined judgements in Figure \ref{fig:ana-syn}. Typing contexts, $\hGamma$, map each variable $x \in \domof{\hGamma}$ to a hypothesis $x : \htau$ in the usual manner. We identify the context up to exchange and adopt the standard identification convention for formal structures that differ only up to alpha-equivalence. 

Derivations of the type analysis judgement, $\hana{\hGamma}{\hexp}{\htau}$, establish that $\hexp$ can appear where an expression of type $\htau$ is expected. Derivations of the type synthesis judgement, $\hsyn{\hGamma}{\hexp}{\htau}$, infer a type from $\hexp$, which is necessary in positions where an expected type is not available (e.g. at the top level.) Algorithmically, the type is an ``input'' of the type analysis judgement, but an ``output'' of the type synthesis judgement. %The rules describe a \emph{local type inference} scheme, i.e. type ascriptions are unnecessary when an expression is being analyzed against a known type.
Making a judgemental distinction between these two notions will be essential in our action semantics (Sec. \ref{sec:actions}.)


 %We use the metavariable $\Gamma$ for \emph{complete typing contexts}, i.e. typing contexts where each hypothesis mentions only complete types.




\begin{subequations}\label{rules:syn-ana}
Type synthesis is stronger than type analysis in that if an expression is able to synthesize a type, it can also be analyzed against that type, or any other \emph{consistent} type, according to the \emph{subsumption rule}, Rule (\ref{rule:ana-subsume}).

The \emph{H-type consistency judgement}, $\tcompat{\htau}{\htau'}$, that appears as a premise in the subsumption rule is a reflexive and symmetric (but not transitive) relation between H-types defined judgementally in Figure \ref{fig:type-consistency}. This relation coincides with equality for complete H-types. Two incomplete H-types are consistent if they differ only at positions where a hole appears in either type. The type hole is therefore consistent with every type. This notion of H-type consistency coincides with the notion of type consistency that Siek and Taha discovered in their foundational work on gradual type systems, if we interpret the type hole as the $?$ (i.e. unknown) type \cite{Siek06a}.

Rule (\ref{rule:syn-lam}) defines analysis for lambda abstractions, $\hlam{x}{\hexp}$. There is no type synthesis rule that applies to this form, so lambda abstractions can appear only in analytic position, i.e. where an expected type is known.\footnote{It is possible to also define a ``half-annotated'' synthetic lambda form, $\lambda x{:}\tau.e$, but for simplicity, we leave it out \cite{DBLP:conf/tldi/ChlipalaPH05}.} Rule (\ref{rule:syn-lam}) is not quite the standard rule, reproduced below:
\begin{equation*}
\inferrule{
  \hana{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\tarr{\htau_1}{\htau_2}}
}
\end{equation*}
The problem is that this standard rule alone leaves us unable to analyze lambda abstractions against the type hole, because the type hole is not immediately of the form $\tarr{\htau_1}{\htau_2}$. There are two plausible solutions to this problem. One solution would be to define a second rule specifically for this case:
\begin{equation*}
\inferrule{
  \hana{\hGamma, x : \tehole}{\hexp}{\tehole}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\tehole}
}
\end{equation*}
Intead, we combine these two possible rules into a single rule through the simple auxiliary \emph{matched arrow type} judgement, $\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$, defined in Figure \ref{fig:type-consistency}. This judgement leaves arrow types alone and assigns the type hole the matched arrow type $\tarr{\tehole}{\tehole}$. It is easy to see that the two rules above are admissible by appeal to Rule (\ref{rule:syn-lam}) and the matched arrow type judgement. Encouragingly, this judgement also arises in the study of gradual type systems \cite{DBLP:conf/popl/CiminiS16,DBLP:conf/popl/GarciaC15,DBLP:conf/popl/RastogiCH12}.

Rule (\ref{rule:syn-asc}) defines type synthesis of expressions of ascription form, $\hexp : \htau$. This allows the user to explicitly state  a type for the ascribed expression to be analyzed against.

Rule (\ref{rule:syn-var}) is the standard rule for variables. 

Rule (\ref{rule:syn-ap}) is again nearly the standard rule for function application. It also makes use of the matched function type judgement to combine what would otherwise need to be two rules for function application -- one for when $e_1$ synthesizes an arrow type, and another for when $e_1$ synthesizes the type hole. Indeed, Siek and Taha needed two application rules for the same fundamental reason \cite{Siek06a}. Later work on gradual typing introduced this notion of type matching to resolve this redundancy.

Rule (\ref{rule:syn-num}) states that numbers synthesize the $\tnum$ type. Rule (\ref{rule:syn-plus}) states that $\hexp_1 + \hexp_2$ behaves like a function over numbers. 

The rules described so far are sufficient to type complete H-expressions. The two remaining rules give H-expressions with holes a well-defined static semantics.

Rule (\ref{rule:syn-ehole}) states that the empty expression hole synthesizes the type hole.


A non-empty hole contains an H-expression that is ``under construction'', as described in Sec. \ref{sec:example}. According to Rule (\ref{rule:syn-hole}), this inner  expression must synthesize some type, but, like the empty hole,  non-empty holes synthesize the type hole. 


% \begin{equation}\label{rule:tcompat-comm}
% \inferrule{
%   \tcompat{\htau}{\htau'}
% }{
%   \tcompat{\htau'}{\htau}
% }
% \end{equation}
% \begin{equation}\label{rule:tcompat-num}
% \inferrule{ }{
%   \tcompat{\tnum}{\tnum}
% }
% \end{equation}
% \begin{equation}\label{rule:tcompat-arr}
% \inferrule{
%   \tcompat{\htau_1}{\htau_1'}\\
%   \tcompat{\htau_2}{\htau_2'}
% }{
%   \tcompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
% }
% \end{equation}

Given these rules, it is instructive to derive the following (by subsumption):
\[\hana{incr : \tarr{\tnum}{\tnum}}{\hhole{incr}}{\tnum}\]
% This is the key premise necessary to synthesize the $\tnum$ type for the H-expression that results from cursor erasure -- defined next -- of the Z-expression on Line 16 of Fig. \ref{fig:second-example}. %In other words, this mechanism is essential if  users are to able to construct a program in anything but an ``outside in'' fashion.

% The final rule handles function applications where the expression in function position synthesizes a hole type, rather than an arrow type. We treat it as if it had instead synthesized $\tarr{\tehole}{\tehole}$:
% \begin{equation}\label{rule:syn-ap-2}
% \inferrule{
%   \hsyn{\hGamma}{\hexp_1}{\tehole}\\
%   \hana{\hGamma}{\hexp_2}{\tehole}
% }{
%   \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\tehole}
% }
% \end{equation}

% \todo{redundant text w/ citation}
% The hole type behaves much like the type $?$ in prior work by Siek and Taha on gradual types for functional languages \cite{Siek06a}. Their system (which was not bidirectionally typed nor an editor model) also needed to define two rules for function application. In general, when a premise requires that a synthesized type be of a particular form, we need a special case where the synthesized hole type is treated instead as if it were the ``holey-est'' type of that form.\footnote{Alternatively, we might add a rule that allows expressions that synthesize hole type to then non-deterministically synthesize any other type, but maintaining determinism is useful in practice, so we avoid this approach.}

\end{subequations}
\subsection{Z-types and Z-expressions}\label{sec:cursors}
\newcommand{\cvert}{{\,{\vert}\,}}
\begin{figure}[t]
\hspace{-3px}$\arraycolsep=2pt\begin{array}{lllllll}
\mathsf{ZTyp} & \ztau & ::= &
  %\zlsel{\htau} ~\vert~
  \zwsel{\htau} \cvert
  %\zrsel{\htau} ~\vert~
  \tarr{\ztau}{\htau} \cvert
  \tarr{\htau}{\ztau} \\
\mathsf{ZExp} & \zexp & ::= &
  %\zlsel{\hexp} ~\vert~
  \zwsel{\hexp} \cvert
  %\zrsel{\hexp} ~\vert~
  \zexp : \htau \cvert
  \hexp : \ztau \cvert
  \hlam{x}{\zexp} \cvert
  \hap{\zexp}{\hexp} \cvert
  \hap{\hexp}{\zexp} \cvert
  \hadd{\zexp}{\hexp} \cvert
  \hadd{\hexp}{\zexp} \cvert
  \hhole{\zexp}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of Z-types and Z-expressions.}
\label{fig:zexp-syntax}
\end{figure}

Hazelnut's action semantics operates over Z-types, $\ztau$, and Z-expressions, $\zexp$. Figure \ref{fig:zexp-syntax} defines the syntax of Z-types and Z-expressions. A Z-type (resp. Z-expression) represents an H-type (resp. H-expression) with a single superimposed \emph{cursor}.

The only base cases in these inductive grammars are $\zwsel{\htau}$ and $\zwsel{\hexp}$, which identify the H-type or H-expression that the cursor is on. All of the other forms correspond to the recursive forms in the syntax of H-types and H-expressions, and contain exactly one ``hatted'' subterm that identifies the subtree where the cursor will be found. Any other sub-term is ``dotted'', i.e. it is either an H-type or H-expression. Taken together, every Z-type and Z-expression contains exactly one selected H-type or H-expression by construction. This can be understood as an instance of Huet's \emph{zipper pattern} \cite{JFP::Huet1997} (which, coincidentally, Huet encountered while implementing a structure editor.)

We write $\removeSel{\ztau}$ for the H-type constructed by erasing the cursor from $\ztau$, which we refer to as the \emph{cursor erasure} of $\ztau$. This straightforward metafunction is defined as follows:
\begin{align*}
%\removeSel{(\zlsel{\htau})} & = \htau\\
\removeSel{(\zwsel{\htau})} & = \htau\\
%\removeSel{(\zrsel{\htau})} & = \htau\\
\removeSel{(\tarr{\ztau}{\htau})} & = \tarr{\removeSel{\ztau}}{\htau}\\
\removeSel{(\tarr{\htau}{\ztau})} & = \tarr{\htau}{\removeSel{\ztau}}
\end{align*}

Similarly, we write $\removeSel{\zexp}$ for the H-expression constructed by erasing the cursor from the Z-expression $\zexp$, i.e. the cursor erasure of $\zexp$. The definition of this metafunction is analogous, so we omit it for concision (see supplement.)
% \begin{align*}
% %\removeSel{(\zlsel{\hexp})} & = \hexp\\
% \removeSel{(\zwsel{\hexp})} & = \hexp\\
% %\removeSel{(\zrsel{\hexp})} & = \hexp\\
% \removeSel{(\zexp : \htau)} & = \removeSel{\zexp} : \htau\\
% \removeSel{(\hexp : \ztau)} & = \hexp : \removeSel{\ztau}\\
% \removeSel{(\hlam{x}{\zexp})} & = \hlam{x}{\removeSel{\zexp}}\\ogoo
% \removeSel{(\hap{\zexp}{\hexp})} & = \hap{\removeSel{\zexp}}{\hexp}\\
% \removeSel{(\hap{\hexp}{\zexp})} & = \hap{\hexp}{\removeSel{\zexp}}\\
% \removeSel{(\hadd{\zexp}{\hexp})} & = \hadd{\removeSel{\zexp}}{\hexp}\\
% \removeSel{(\hadd{\hexp}{\zexp})} & = \hadd{\hexp}{\removeSel{\zexp}}\\
% \removeSel{\hhole{\zexp}} &= \hhole{\removeSel{\zexp}}
% \end{align*}

\subsection{Actions}\label{sec:actions}


We now arrive at the heart of Hazelnut: its \emph{bidirectional action semantics}.  
Figure \ref{fig:action-syntax} defines the syntax of \emph{actions}, $\alpha$, some of which involve \emph{directions}, $\delta$, and \emph{shapes}, $\psi$. 

Expression actions are governed by two mutually defined judgements, 1) the \emph{synthetic action judgement}:
\[
\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}
\]
and 2) \emph{the analytic action judgement}:
\[
\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}
\]

In some Z-expressions, the cursor is in a type ascription, so we also need a \emph{type action judgement}, pronounced ``performing $\alpha$ on $\ztau$ results in $\ztau'$'':
\[
\performTyp{\ztau}{\alpha}{\ztau'}
\]


% The type action judgement appears as a premise in the rules that handle Z-expressions where the cursor is inside a . 
% \[\begin{array}{ll}
% %\textbf{Judgement Form} & \textbf{Description}\\
% & 
% \end{array}\]
% \[
% \begin{array}{l}
% \fbox{$\performTyp{\ztau}{\alpha}{\ztau'}$} ~~ \text{Performing $\alpha$ on $\ztau$ produces $\ztau'$}\\
% \fbox{$\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$} \\
% \quad \text{Performing $\alpha$ on $\zexp$ when $\removeSel{\zexp}$ synthesizes type $\htau$}\\
% \quad \text{produces $\zexp'$ such that $\removeSel{\zexp'}$ synthesizes type $\htau'$}\\
% \fbox{$\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$} \\
% \quad \text{Performing $\alpha$ on $\zexp$ when analyzing $\removeSel{\zexp}$ against $\htau$}\\
% \quad \text{produces $\zexp'$, such that $\removeSel{\zexp'}$ can also be analyzed}\\
% \quad \text{against $\htau$}
% \end{array}\]
\subsubsection{Sensibility}


Before giving the rules for these judgements, let us state the key metatheorem: \emph{sensibility}. This metatheorem deeply inform the design of the rules, given starting in Sec. \ref{sec:action-subsumption}. Its proof, which is mechanized in Agda, is by straightforward induction, so the reader is encouraged to think about the relevant cases of these proofs as we present the rules. 
\begin{theorem}[Action Sensibility]\label{thrm:actsafe} Both of the following hold:\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
\item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ 
   then
  $\hsyn{\hGamma}{\removeSel{\zexp'}}{\htau'}$.
\item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
   $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ then
  $\hana{\hGamma}{\removeSel{\zexp'}}{\htau}$.
\end{enumerate}
\end{theorem}
\noindent In other words, if an edit state (i.e. a Z-expression) is statically meaningful, i.e. its cursor erasure is well-typed, then performing an action on it leaves the resulting edit state statically meaningful. In particular, the first clause of Theorem \ref{thrm:actsafe} establishes that when an action is performed on an edit state whose cursor erasure synthesizes an H-type, the result is an edit state whose cursor erasure also synthesizes some (possibly different) H-type. The second clause establishes that when an action is performed using the analytic action judgement on an edit state whose cursor erasure analyzes against some H-type, the result is a Z-expression whose cursor erasure also analyzes against the same H-type. % Non-empty holes allow us to avoid top-down program construction becau but rather can construct fragments of the program inside a hole until ready to ``expose'' them to type analysis.


\begin{figure}[t]
\hspace{-3px}$\arraycolsep=3pt\begin{array}{llcllll}
\mathsf{Action} & \alpha & ::= &
  \aMove{\delta} ~\vert~
  %\aSelect{\delta} ~\vert~
  \aDel ~\vert~
  %\aReplace{\htau} ~\vert~
  %\aReplace{\hexp} ~\vert~
  \aConstruct{\psi} ~\vert~
  \aFinish\\
\mathsf{Dir} & \delta & ::= &
  \dChild ~\vert~
  \dParent ~\vert~
  \dNext \\ % ~\vert~
  % \dPrev\\
\mathsf{Shape} & \psi & ::= &
  \farr ~\vert~
  \fnum \\
& & \vert &
  \fasc ~\vert~
  \fvar{x} ~\vert~
  \flam{x} ~\vert~
  \fap ~\vert~
  \farg ~\vert~
  \fnumlit{n} ~\vert~
  \fplus\\
& & \vert & 
  {\color{gray}\fnehole}
\end{array}$
%\textbf{Sort} & & & \textbf{Operational Form} & \textbf{Stylized Form} & \textbf{Description}\\
\caption{Syntax of actions.}
\label{fig:action-syntax}
\end{figure}

% \subsubsection{Determinism}
% Another useful property that we maintain is \emph{action determinism}, i.e. that performing an action should produce a unique result. Formally, this is established as follows:
% \begin{theorem}[Action Determinism] All of the following hold:
% \label{thrm:actdet}
% \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
% \item If $\performTyp{\ztau}{\alpha}{\ztau'}$ and $\performTyp{\ztau}{\alpha}{\ztau''}$ then $\ztau'=\ztau''$.
% \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
%   $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and
%   $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}{\htau''}$ then
%   $\zexp' = \zexp''$ and $\htau' = \htau''$.
% % \item If all of

%   \begin{quote}
%     \begin{enumerate}
%     \item $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$, and
%     \item $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$, and
%     \item $\tcompat{\htau}{\htau'}$, and
%     \item either $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ or
%       $\performAna{\hGamma}{\zexp}{\htau'}{\alpha}{\zexp''}$
%     \end{enumerate}
%   \end{quote}
%   hold, then $\zexp' = \zexp''$.
% % \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
% %   $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ and
% %   $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ then $\zexp' =
% %   \zexp''$.
% % \end{enumerate}
% \end{theorem}

\subsubsection{Type Inconsistency}
In some of the rules below, we will need to supplement our definition of type consistency from Figure \ref{fig:type-consistency} with a definition of \emph{type inconsistency}, written $\tincompat{\htau}{\htau'}$. One can define this notion either directly as the metatheoretic negation of type consistency, or as a separate inductively defined judgement. The supplement does the latter. The key rule establishes that arrow types are inconsistent with $\tnum$:
% \begin{subequations}
  % \begin{equation}
  %   \inferrule{
  %     \tincompat{\htau}{\htau'}
  %   }{
  %     \tincompat{\htau'}{\htau}
  %   }
  % \end{equation}
  \begin{equation*}
    \inferrule{ }{
      \tincompat{\tnum}{\tarr{\htau_1}{\htau_2}}
    }
  \end{equation*}
  % \begin{equation}
  %   \inferrule{
  %     \tincompat{\htau_1}{\htau_1'}
  %   }{
  %     \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
  %   }
  % \end{equation}
  % \begin{equation}
  %   \inferrule{
  %     \tincompat{\htau_2}{\htau_2'}
  %   }{
  %     \tincompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
  %   }
  % \end{equation}
% \end{subequations}
% The remaining rules, given in the appendix, establish that type incompatibility is symmetric.
The mechanization proves that this judgemental definition of type inconsistency is indeed the negation of type consistency.


\subsubsection{Action Subsumption}\label{sec:action-subsumption}

The action semantics includes a subsumption rule similar to the subsumption rule, Rule (\ref{rule:ana-subsume}), in the statics:
\begin{equation}\label{rule:action-subsume}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau'}\\
    \performSyn{\hGamma}{\zexp}{\htau'}{\alpha}{\zexp'}{\htau''}\\
    \tcompat{\htau}{\htau''}%\\\\
    % \zexp, \alpha~\mathsf{subsumes}
  }{
    \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}
  }
\end{equation}
In other words, if the cursor erasure of the edit state synthesizes a type, then we defer to the synthetic action judgement, as long as the type of the resulting cursor erasure is consistent with the type provided for analysis.  The case involving Rule (\ref{rule:action-subsume}) in the proof of Theorem \ref{thrm:actsafe} goes through by induction and static subsumption, i.e. Rule (\ref{rule:ana-subsume}). Algorithmically, subsumption should be the rule of last resort.

% We need to make some exceptions in this rule to maintain determinism, because certain construction actions, described in Sec. \ref{sec:construction}, behave slightly differently depending on whether a type is known. We do so by defining a simple judgement $\alpha~\mathsf{subsumes}$ that excludes these action forms:\todo{put into supp}
% \begin{subequations}
% \begin{equation}\label{rule:subsumes}
% \inferrule{
%   \alpha \neq \aConstruct{\fasc}\\
%   (\forall x) \alpha \neq \aConstruct{\flam{x}} 
% }{
%   \zexp, \alpha~\mathsf{subsumes}
% }
% \end{equation}
% \begin{equation}\label{rule:subsumes}
% \inferrule{
%   \zexp \neq \zwsel{\hexp}
% }{
%   \zexp, \alpha~\mathsf{subsumes}
% }
% \end{equation}
% \end{subequations}
% Algorithmically, this captures the notion that subsumption should be the case of last resort.

\subsubsection{Relative Movement}\label{sec:movement} 
The rules below define relative movement within Z-types. They should be self-explanatory:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }{
      \aMove{\dChild}
    }{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-parent-arr-right}
  \inferrule{ }{
    \performTyp{
      \tarr{{\htau_1}}{\zwsel{\htau_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-nextSib-arr}
  \inferrule{ }{
    \performTyp{
      \tarr{\zwsel{\htau_1}}{{\htau_2}}
    }{
      \aMove{\dNext}
    }{
      {\tarr{\htau_1}{\zwsel{\htau_2}}}
    }
  }
\end{equation}
% \begin{equation}
%   \inferrule{ }{
%     \performTyp{
%       \tarr{{\htau_1}}{\zwsel{\htau_2}}
%     }{
%       \aMove{\dPrev}
%     }{
%       {\tarr{\zwsel{\htau_1}}{{\htau_2}}}
%     }
%   }
% \end{equation}
% \begin{equation}
% \inferrule{
%   \performTyp{
%     \ztau
%   }{
%     \aMove{\delta}
%   }{
%     \ztau'
%   }
% }{
%   \performTyp{
%     \tarr{\ztau}{\htau}
%   }{
%     \aMove{\delta}
%   }{
%     \tarr{\ztau'}{\htau}
%   }
% }
% \end{equation}
% \begin{equation}
%   \inferrule{
%     \performTyp{
%       \ztau
%     }{
%       \aMove{\delta}
%     }{
%       \ztau'
%     }
%   }{
%     \performTyp{
%       \tarr{\htau}{\ztau}
%     }{
%       \aMove{\delta}
%     }{
%       \tarr{\htau}{\ztau}
%     }
%   }
% \end{equation}
\end{subequations}
Two more rules are needed to recurse into the zipper structure. We define these zipper rules in an action-independent manner in Sec. \ref{sec:zipper-cases}. 
% The final two rules above recurse into the zipper structure.

The rules for relative movement within Z-expressions are similarly straightforward. Movement is type-independent, so we defer to an auxiliary expression movement judgement in both the analytic and synthetic case:
\begin{subequations}
\begin{equation}
\inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performSyn{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}{\htau}
}
\end{equation}
\begin{equation}
  \inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performAna{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}
}
\end{equation}
\end{subequations}
% \begin{figure}
% \judgbox{\performMove{\zexp}{\aMove{\delta}}{\zexp'}}{(Additional movement-action rules:)}
% \begin{displaymath}
% \begin{array}{@{}rcl}
%   %\multicolumn{3}{l}{\textbf{Movement Actions for Sum Type Forms}:}
%   %\\
%   \TABperformMove
%       {\zwsel{\hexp : \htau}}
%       {\aMove{\dChild}}
%       {      \zwsel{\hexp} : \htau}
%   \\
%   \TABperformMove
%       {
%       \zwsel{\hexp} : \htau
%     }{
%       \aMove{\dParent}
%     }{
%       \zwsel{\hexp : \htau}
%     }
%   \\
%   \TABperformMove
%     {
%       \hexp : \zwsel{\htau}
%     }{
%       \aMove{\dParent}
%     }{
%       \zwsel{\hexp : \htau}
%     }
%   \\
%   \TABperformMove
%       {
%       \zwsel{\hexp} : \htau
%     }{
%       \aMove{\dNext}
%     }{
%       \hexp : \zwsel{\htau}
%     }
%   \\[2mm]
%   \TABperformMove
%       {      {\tsum{{\htau_1}}{{\zwsel{\htau_2}}}}}
%       {\aMove{\dParent}}
%       {\zwsel{\tsum{{\htau_1}}{\htau_2}}}
%   \\[2mm]
%   \TABperformMove
%       {\zwsel{\hinj{i}{\hexp}}}
%       {\aMove{\dChild}}
%       {\hinj{i}{\zwsel{\hexp}}}      
%   \\
%   \TABperformMove
%       {\hinj{i}{\zwsel{\hexp}}}      
%       {\aMove{\dParent}}
%       {\zwsel{\hinj{i}{\hexp}}}
%   \\[2mm]
%   \TABperformMove
%       {\zwsel{\hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2}}}
%       {\aMove{\dChild}}
%       {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
%   \\
%   \TABperformMove
%       {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
%       {\aMove{\dNext}}
%       {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
%   \\
%   \TABperformMove
%       {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
%       {\aMove{\dNext}}
%       {      {\hcase{{\hexp}}{x}{{\hexp_1}}{y}{\zwsel{\hexp_2}}}}
%   \\
%   \TABperformMove
%       {      {\hcase{{\hexp}}{x}{{\hexp_1}}{y}{\zwsel{\hexp_2}}}}
%       {\aMove{\dPrev}}
%       {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
%   \\
%   \TABperformMove
%       {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
%       {\aMove{\dPrev}}
%       {      {\hcase{{\zwsel{\hexp}}}{x}{{\hexp_1}}{y}{{\hexp_2}}}}
%   \\
%   \TABperformMove
%       {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
%       {\aMove{\dParent}}
%       {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
%   \\
%   \TABperformMove
%       {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
%       {\aMove{\dParent}}
%       {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
%   \\
%   \TABperformMove
%       {      {\hcase{{\hexp}}{x}{\hexp_1}{y}{\zwsel{\hexp_2}}}}
%       {\aMove{\dParent}}
%       {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
% \end{array}
% \end{displaymath}
% \caption{Movement action semantics for sum type forms.}
% \end{figure}
The expression movement judgement is defined as follows.

\paragraph{Ascription}
\begin{subequations}
  \begin{equation}
    \label{r:movefirstchild}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp : \htau}
    }{
      \aMove{\dChild}
    }{
      \zwsel{\hexp} : \htau
    }
  }
\end{equation}
\begin{equation}
  \label{r:moveparent}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp} : \htau
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-parent-asc-right}
  \inferrule{ }{
    \performTyp{
      \hexp : \zwsel{\htau}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}
\begin{equation}
  \label{r:movenextsib}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp} : \htau
    }{
      \aMove{\dNext}
    }{
      \hexp : \zwsel{\htau}
    }
  }
\end{equation}
% \begin{equation}
%   \label{r:moveprevsib}
%   \inferrule{ }{
%     \performTyp{
%       \hexp : \zwsel{\htau}
%     }{
%       \aMove{\dPrev}
%     }{
%       \zwsel{\hexp} : \htau
%     }
%   }
% \end{equation}
% \begin{equation}
% \inferrule{
%   \performTyp{
%     \zexp
%   }{
%     \aMove{\delta}
%   }{
%     \zexp'
%   }
% }{
%   \performTyp{
%     \zexp : \htau
%   }{
%     \aMove{\delta}
%   }{
%     \zexp' : \htau
%   }
% }
% \end{equation}
% \begin{equation}
%   \inferrule{
%     \performTyp{
%       \ztau
%     }{
%       \aMove{\delta}
%     }{
%       \ztau'
%     }
%   }{
%     \performTyp{
%       \hexp : \ztau
%     }{
%       \aMove{\delta}
%     }{
%       \hexp : \ztau'
%     }
%   }
% \end{equation}


\paragraph{Lambda}\vspace{-3px}
\begin{equation}\label{r:movefirstchild-lam}
\inferrule{ }{
  \performMove{
    \zwsel{\hlam{x}{\hexp}}
  }{
    \aMove{\dChild}
  }{
    \hlam{x}{\zwsel{\hexp}}
  }
}
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hlam{x}{\zwsel{\hexp}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hlam{x}{\hexp}}
    }
  }
\end{equation}
\paragraph{Application}\vspace{-5px}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChild}
    }{
      \hap{\zwsel{\hexp_1}}{\hexp_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hap{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}\label{r:moveparent-ap2}
  \inferrule{ }{
    \performMove{
      \hap{{\hexp_1}}{\zwsel{\hexp_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hap{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dNext}
    }{
      \hap{\hexp_1}{\zwsel{\hexp_2}}
    }
  }
\end{equation}
% \begin{equation}
%   \inferrule{ }{
%     \performMove{
%       \hap{\hexp_1}{\zwsel{\hexp_2}}
%     }{
%       \aMove{\dPrev}
%     }{
%       \hap{\zwsel{\hexp_1}}{\hexp_2}
%     }
%   }
% \end{equation}

\paragraph{Plus}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChild}
    }{
      \hadd{\zwsel{\hexp_1}}{\hexp_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hadd{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hadd{{\hexp_1}}{\zwsel{\hexp_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hadd{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dNext}
    }{
      \hadd{\hexp_1}{\zwsel{\hexp_2}}
    }
  }
\end{equation}
% \begin{equation}
%   \inferrule{ }{
%     \performMove{
%       \hadd{\hexp_1}{\zwsel{\hexp_2}}
%     }{
%       \aMove{\dPrev}
%     }{
%       \hadd{\zwsel{\hexp_1}}{\hexp_2}
%     }
%   }
% \end{equation}

\paragraph{Non-Empty Hole}
\begin{equation}
\inferrule{ }{
  \performMove{
    \zwsel{\hhole{\hexp}}
  }{
    \aMove{\dChild}
  }{
    \hhole{\zwsel{\hexp}}
  }
}
\end{equation}
\begin{equation}\label{r:moveparent-hole}
  \inferrule{ }{
    \performMove{
      \hhole{\zwsel{\hexp}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hhole{\hexp}}
    }
  }
\end{equation}
Again, additional rules are needed to recurse into the zipper structure, but we will define these zipper rules in an action-independent manner in Sec. \ref{sec:zipper-cases}. 
\end{subequations}

The rules above are numerous and fairly uninteresting. That makes them quite hazardous -- we might make a mistake absent-mindedly. One check against this is to prove a lemma that establishes that movement actions move the cursor but do not change the cursor erasure.

\begin{theorem}[Movement Erasure Invariance]\label{lemma:movement-erasure} ~
\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px] 
\item If $\performMove{\ztau}{\aMove{\delta}}{\ztau'}$ then $\removeSel{\ztau}=\removeSel{\ztau'}$.
\item If $\performMove{\zexp}{\aMove{\delta}}{\zexp'}$ then $\removeSel{\zexp}=\removeSel{\zexp'}$.
\end{enumerate}
\end{theorem}
\noindent Theorem \ref{lemma:movement-erasure} is useful also in that the relevant cases of Theorem \ref{thrm:actsafe} are straightforward by its application.

Another useful check is to establish \emph{reachability}, i.e. that it is possible, through a sequence of movement actions, to move the cursor from any position to any other position within a well-typed H-expression. 

This requires developing machinery for reasoning about sequences of actions. There are two possibilities: we can either add a sequencing action, $\alpha; \alpha$, directly to the syntax of actions, or we can define a syntax for lists of actions, $\bar{\alpha}$, together with iterated action judgements. To keep the core of the action semantics small, we take the latter approach in Figure \ref{fig:multistep}.


A simple auxiliary judgement, $\bar\alpha~\mathsf{movements}$, defined in the supplement, establishes that $\bar\alpha$ consists only of actions of the form $\aMove{\delta}$.

With these definitions, we can state reachability as follows:

\begin{theorem}[Reachability]\label{thrm:reachability} ~
\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
\item If $\removeSel{\ztau}=\removeSel{\ztau'}$ then there exists some $\bar\alpha$ such that $\bar{\alpha}~\mathsf{movements}$ and $\performTyp{\ztau}{\bar\alpha}{\ztau'}$.
\item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\removeSel{\zexp}=\removeSel{\zexp'}$ then there exists some $\bar{\alpha}$ such that $\bar{\alpha}~\mathsf{movements}$ and $\performAna{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}$. 
\item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and $\removeSel{\zexp}=\removeSel{\zexp'}$ then there exists some $\bar{\alpha}$ such that $\bar{\alpha}~\mathsf{movements}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zexp'}{\htau}$.
\end{enumerate}
\end{theorem}


\begin{figure}
$\mathsf{ActionList}$~~$\bar{\alpha} ::= \cdot ~\vert~ \alpha; \bar{\alpha}$\vspace{4px}\\
\fbox{$\performTyp{\ztau}{\bar{\alpha}}{\ztau'}$}
\vspace{-10px}\begin{mathpar}
\inferrule{ }{
    \performTyp{\ztau}{\cdot}{\ztau}
}

\inferrule{
  \performTyp{\ztau}{\alpha}{\ztau'}\\
  \performTyp{\ztau'}{\bar{\alpha}}{\ztau''}
}{
  \performTyp{\ztau}{\alpha; \bar{\alpha}}{\ztau''}
}
\end{mathpar}
\fbox{$\performSyn{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}{\htau'}$}
\vspace{-10px}\begin{mathpar}
\inferrule{ }{
  \performSyn{\hGamma}{\zexp}{\htau}{\cdot}{\zexp}{\htau}
}

\inferrule{
  \performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}\\\\
  \performSyn{\hGamma}{\zexp'}{\htau'}{\bar{\alpha}}{\zexp''}{\htau''}
}{
  \performSyn{\hGamma}{\zexp}{\htau}{\alpha; \bar{\alpha}}{\zexp''}{\htau''}
}
\end{mathpar}
\fbox{$\performAna{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}$}
\vspace{-10px}\begin{mathpar}
\inferrule{ }{
  \performAna{\hGamma}{\zexp}{\htau}{\cdot}{\zexp}
}

\inferrule{
  \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}\\\\
  \performAna{\hGamma}{\zexp'}{\htau}{\bar\alpha}{\zexp''}
}{
  \performAna{\hGamma}{\zexp}{\htau}{\alpha; \bar\alpha}{\zexp''}
}
\end{mathpar}
\caption{Iterated Action Judgements}
\label{fig:multistep}
\end{figure}

The simplest way to prove Theorem \ref{thrm:reachability} is to  break it into two lemmas. Lemma \ref{lemma:reach-up} establishes that you can always move the cursor to the outermost position in an expression. This serves as a check on our $\aMove{\dParent}$ rules.
\begin{lemma}[Reach Up]\label{lemma:reach-up} ~
\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
\item If $\removeSel{\ztau}=\htau$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ and $\performTyp{\ztau}{\bar\alpha}{\zwsel{\htau}}$.
\item If $\hana{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ and $\performAna{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zwsel{\hexp}}$. 
\item If $\hsyn{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ and $\performSyn{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zwsel{\hexp}}{\htau}$.
\end{enumerate}
\end{lemma}
Lemma \ref{lemma:reach-down} establishes that you can always move the cursor from the outermost position to any other position. This serves as a check on our $\aMove{\dChild}$ and $\aMove{\dNext}$ rules. 
\begin{lemma}[Reach Down]\label{lemma:reach-down} ~
\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
\item If $\removeSel{\ztau}=\htau$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ and $\performTyp{\zwsel{\htau}}{\bar\alpha}{\ztau}$.
\item If $\hana{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ and $\performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\bar\alpha}{\zexp}$.
\item If $\hsyn{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$ then there exists some $\bar\alpha$ such that $\bar\alpha~\mathsf{movements}$ nand $\performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\bar\alpha}{\zexp}{\htau}$.
\end{enumerate}
\end{lemma}
Theorem \ref{thrm:reachability} follows by straightforward composition of these two lemmas. %(The witness to the existential is not, of course, the shortest path between any two cursor locations.)

% \paragraph{Reachability}

% We give the following theorem to demonstrate that the rules for movement do
% indeed capture the process of moving the focus to any editable position
% within a term. Intuitively, given two zippered expressions that are the
% same up to the erasure of focus, its proof gives a list of composable
% actions that, when applied to the first term produces the second.

% As a consequence of applying Theorem \ref{thrm:actsafe} inductively at
% every action in such a list, it is possible consider moving to an ill-typed
% term. Therefore the statement here matches the mutually recursive structure
% of the bidirectional typing judgements.

% \begin{theorem}[Reachability]\todo{why $\htau$ and not $\ztau$?}
% \label{thrm:reach}
% Both of the following hold:
% \begin{enumerate}
%   \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
%    $\hsyn{\hGamma}{\removeSel{\zexp'}}{\htau}$ and $\removeSel{\zexp}
%    = \removeSel{\zexp'}$ then $\exists L \in \mathit{list}
%    ~\mathtt{action}$ such that $\mathit{iterate}~ L~ \zexp
%    = \zexp'$.

%   \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
%    $\hana{\hGamma}{\removeSel{\zexp'}}{\htau}$ and $\removeSel{\zexp}
%    = \removeSel{\zexp'}$ then $\exists L \in \mathit{list}
%    ~\mathtt{action}$ such that $\mathit{iterate}~ L~ \zexp
%    = \zexp'$.
% \end{enumerate}
% \end{theorem}


\subsubsection{Deletion} The $\aDel$ action inserts an empty hole at the cursor, deleting what was there before.

The type action rule for $\aDel$ is self-explanatory:
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aDel
    }{
      \zwsel{\tehole}
    }
  }
\end{equation}
% \begin{equation}
%   \inferrule{
%     \performTyp{\ztau}{\aDel}{\ztau'}
%   }{
%     \performTyp{\tarr{\ztau}{\htau}}{\aDel}{\tarr{\ztau'}{\htau}}
%   }
% \end{equation}
% \begin{equation}
%   \inferrule{
%     \performTyp{\ztau}{\aDel}{\ztau'}
%   }{
%     \performTyp{\tarr{\htau}{\ztau}}{\aDel}{\tarr{\htau}{\ztau'}}
%   }
% \end{equation}

Deletion within a Z-expression is similarly straightforward:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\aDel}{\zwsel{\hehole}}{\tehole}
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\aDel}{\zwsel{\hehole}}
  }
\end{equation}
%\end{subequations}
% The base case turns into a hole:
%\begin{subequations}
% \begin{equation}
% \inferrule{ }{
%   \performDel{\zwsel{\hexp}}{\hehole}
% }
% \end{equation}
% The rules for the recursive ascription case is shown below. The other recursive cases are analagous:
% \begin{equation}
%   \inferrule{
%     \performDel{\zexp}{\zexp'}
%   }{
%     \performDel{\zexp : \htau}{\zexp' : \htau}
%   }
% \end{equation}
% \begin{equation}
%   \inferrule{
%     \performTyp{\ztau}{\aDel}{\ztau'}
%   }{
%     \performDel{\hexp : \ztau}{\hexp : \ztau'}
%   }
% \end{equation}
\end{subequations}

\subsubsection{Construction}\label{sec:construction} The construction actions, $\aConstruct{\psi}$, are used to construct terms of a shape indicated by $\psi$ at the cursor.

\paragraph{Types} The $\aConstruct{\farr}$ action constructs an arrow type. The H-type under the cursor becomes the argument type, and the cursor is placed on an empty return type hole:
\begin{subequations}
  \begin{equation}
    \label{r:contarr}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aConstruct{\farr}
    }{
      \tarr{\htau}{\zwsel{\tehole}}
    }
  }
\end{equation}

The $\aConstruct{\fnum}$ action replaces an empty type hole under the cursor with the $\tnum$ type:
  \begin{equation}
    \label{r:contnum}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tehole}
    }{
      \aConstruct{\fnum}
    }{
      \zwsel{\tnum}
    }
  }
\end{equation}

% Construction proceeds recursively down the zipper:
%   \begin{equation}
%     \label{r:contarrL}
%   \inferrule{
%     \performTyp{\ztau}{\aConstruct{\psi}}{\ztau'}
%   }{
%     \performTyp{
%       \tarr{\ztau}{\htau}
%     }{
%       \aConstruct{\psi}
%     }{
%       \tarr{\ztau'}{\htau}
%     }
%   }
% \end{equation}
%   \begin{equation}
%     \label{r:contarrR}
%   \inferrule{
%     \performTyp{\ztau}{\aConstruct{\psi}}{\ztau'}
%   }{
%     \performTyp{
%       \tarr{\htau}{\ztau}
%     }{
%       \aConstruct{\psi}
%     }{
%       \tarr{\htau}{\ztau'}
%     }
%   }
% \end{equation}
\end{subequations}

\begin{subequations}

\paragraph{Ascription} The $\aConstruct{\fasc}$ action operates differently depending on whether the H-expression under the cursor synthesizes a type or is being analyzed against a type. In the first case, the synthesized type appears in the ascription:
\begin{equation}
  \label{r:constructasc}
  \inferrule{ }{
    \performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\hexp : \zwsel{\htau}}{\htau}
  }
\end{equation}
In the second case, the type provided for analysis appears in the ascription:
\begin{equation}
  \inferrule{ }{
    \performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\hexp : \zwsel{\htau}}
  }
\end{equation}
% This rule should supercede the subsumption rule, so we excluded $\aConstruct{\fasc}$ from subsumption in Rule (\ref{rule:subsumes}).

\paragraph{Variables} The $\aConstruct{\fvar{x}}$ action places the variable $x$ into an empty hole. If that hole is being asked to synthesize a type, then the result synthesizes the hypothesized type:
\begin{equation}
  \label{r:conevar}
  \inferrule{ }{
    \performSyn{\hGamma, x : \htau}{\zwsel{\hehole}}{\tehole}{\aConstruct{\fvar{x}}}{\zwsel{x}}{\htau}
  }
\end{equation}
If the hole is being analyzed against a type that is consistent with the hypothesized type, then the action semantics goes through the {action subsumption rule} described in Sec. \ref{sec:action-subsumption}. If the hole is being analyzed against a type that is inconsistent with the hypothesized type, $x$ is placed inside a hole:
\begin{equation}
 \label{r:conevar2}
  \inferrule{
    \tincompat{\htau}{\htau'}
  }{
    \performAna{\hGamma, x : \htau'}{\zwsel{\hehole}}{\htau}{\aConstruct{\fvar{x}}}{\hhole{\zwsel{x}}}
  }
\end{equation}
The rule above featured on Line 15 of Figure \ref{fig:second-example}.

\paragraph{Lambdas} The $\aConstruct{\flam{x}}$ action places a lambda abstraction binding $x$ into an empty hole. If the empty hole is being asked to synthesize a type, then the result of the action is a lambda ascribed the type $\tarr{\tehole}{\tehole}$, with the cursor on the argument type hole:
\begin{equation}
  \label{r:conelamhole}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\aConstruct{\flam{x}}}
      {\hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}}
      {\tarr{\tehole}{\tehole}}
  }
\end{equation}
The type ascription is necessary because lambda expressions do not synthesize a type. If the empty hole is being analyzed against a type with matched arrow type, then no ascription is necessary:
\begin{equation}\label{rule:performAna-lam-1}
  \inferrule{
    \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\flam{x}}}
      {\hlam{x}{\zwsel{\hehole}}}
  }
\end{equation}
% Because the ascription is omitted here but included in Rule (\ref{r:conelamhole}), we must exclude all $\aConstruct{\flam{x}}$ actions from subsumption in Rule (\ref{rule:subsumes}).

Finally, if the empty hole is being analyzed against a type that has no matched arrow type, expressed in the premise as inconsistency with $\tarr{\tehole}{\tehole}$, then a lambda ascribed the type $\tarr{\tehole}{\tehole}$
is inserted inside a hole, which defers the type inconsistency as previously discussed:
\begin{equation}\label{rule:performAna-construct-lam-2}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\flam{x}}}
      {\hhole{
        \hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}
      }}
  }
\end{equation}

\paragraph{Application} The $\aConstruct{\fap}$ action applies the expression under the cursor. The following rule handles the case where the synthesized type has matched function type:
\begin{equation}
  \label{r:coneapfn}
  \inferrule{
    \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fap}}
      {\hap{\hexp}{\zwsel{\hehole}}}
      {\htau_2}
  }
\end{equation}
If the expression under the cursor synthesizes a type that is inconsistent with an arrow type, then we must place that expression inside a hole to maintain Theorem \ref{sec:holes}:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fap}}
      {\hap{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tehole}
  }
\end{equation}

The $\aConstruct{\farg}$ action instead places the expression under the cursor in the argument position of an application form. Because the function position is always an empty hole in this situation, we need only a single rule:
\begin{equation}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\farg}}
      {\hap{\zwsel{\hehole}}{\hexp}}
      {\tehole}
  }
\end{equation}

\paragraph{Numbers} The $\aConstruct{\fnumlit{n}}$ action replaces an empty hole with the number expression $\hnum{n}$. If the empty hole is being asked to synthesize a type, then the rule is straightforward:
\begin{equation}
  \label{r:conenumnum}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\aConstruct{\fnumlit{n}}}
      {\zwsel{\hnum{n}}}
      {\tnum}
  }
\end{equation}
If the empty hole is being analyzed against a type that is inconsistent with $\tnum$, then we must place the number expression inside the hole:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\fnumlit{n}}}
      {\hhole{\zwsel{\hnum{n}}}}
  }
\end{equation}

The $\aConstruct{\fplus}$ action constructs a plus expression with the expression under the cursor as its first argument. If that expression synthesizes a type consistent with $\tnum$, then the rule is straightforward:
\begin{equation}\label{rule:construct-plus-compat}
  \inferrule{
    \tcompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hexp}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}
Otherwise, we must place that expression inside a hole:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}

\paragraph{Non-Empty Holes} The final shape is $\fnehole$. This explicitly places the expression under the cursor inside a hole:
\begin{equation}
\inferrule{ }{
  \performSyn
    {\hGamma}
    {\zwsel{\hexp}}
    {\htau}
    {\aConstruct{\fnehole}}
    {\hhole{\zwsel{\hexp}}}
    {\tehole}
}
\end{equation}\end{subequations}

The $\fnehole$ shape is grayed out in Figure \ref{fig:action-syntax} because we do not expect the programmer to perform it explicitly -- other actions automatically insert holes when a type inconsistency would arise. Its inclusion is mainly to make it easier to state another ``checksum'' theorem: \emph{constructability}

\paragraph{Constructability}
To check that we have defined ``enough'' construct actions, we need to establish that we can start from an empty hole and arrive at any well-typed expression with, for simplicity, the cursor on the outside (Lemma \ref{lemma:reach-down} allows us to then move the cursor anywhere else.) As with reachability, we rely on the iterated action judgements defined in Figure \ref{fig:multistep}.
\begin{theorem}[Constructability]\label{thrm:constructability} ~
\begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
\item For every $\htau$ there exists $\bar\alpha$ such that $\performTyp{\zwsel{\tehole}}{\bar\alpha}{\zwsel{\htau}}$.
\item If $\hana{\hGamma}{\hexp}{\htau}$ then there exists $\bar\alpha$ such that $\performAna{\hGamma}{\zwsel{\hhole{}}}{\htau}{\bar\alpha}{\zwsel{\hexp}}$.
\item If $\hsyn{\hGamma}{\hexp}{\htau}$ then there exists $\bar\alpha$ such that $\performSyn{\hGamma}{\zwsel{\hhole{}}}{\tehole}{\bar\alpha}{\zwsel{\hexp}}{\htau}$.
\end{enumerate}
\end{theorem}

\subsubsection{Finishing}
The final action we need to consider is $\aFinish$, which finishes the non-empty hole under the cursor.

If the non-empty hole appears in synthetic position, then it can always be finished:
\begin{subequations}
  \begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\hexp}{\htau'}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\tehole}
      {\aFinish}
      {\zwsel{\hexp}}
      {\htau'}
  }
\end{equation}

If the non-empty hole appears in analytic position, then it can only be finished if the type synthesized for the enveloped expression is consistent with the type that the hole is being analyzed against. This amounts to analyzing the enveloped expression against the provided type (by subsumption):
\begin{equation}\label{r:finishana}
  \inferrule{
    \hana{\hGamma}{\hexp}{\htau}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\htau}
      {\aFinish}
      {\zwsel{\hexp}}
  }
\end{equation}
\end{subequations}

\subsubsection{Zipper Cases}\label{sec:zipper-cases} The rules defined so far handle the base cases, i.e. the cases where the action has ``reached'' the expression under the cursor. We also need to define the recursive cases, which propagate the action into the subtree where the cursor appears, as encoded by the zipper structure. For types, the zipper rules are straightforward:
\begin{subequations}
\begin{equation}
    %\label{r:contarrL}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      \tarr{\ztau}{\htau}
    }{
      \alpha
    }{
      \tarr{\ztau'}{\htau}
    }
  }
\end{equation}
  \begin{equation}
    %\label{r:contarrR}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      \tarr{\htau}{\ztau}
    }{
      \alpha
    }{
      \tarr{\htau}{\ztau'}
    }
  }
\end{equation}
\end{subequations}
For expressions, the zipper rules essentially follow the structure of the corresponding rules in the statics.

\begin{subequations}
In particular, when the cursor is in the body of a lambda expression, the zipper case mirrors Rule (\ref{rule:syn-lam}):
\begin{equation}
\inferrule{
  \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}\\
  \performAna
    {\hGamma, x : \htau_1}
    {\zexp}
    {\htau_2}
    {\alpha}
    {\zexp'}
}{
  \performAna
    {\hGamma}
    {\hlam{x}{\zexp}}
    {\htau}
    {\alpha}
    {\hlam{x}{\zexp'}}
}
\end{equation}

When the cursor is in the expression position of an ascription, we use the analytic  judgement, mirroring Rule (\ref{rule:syn-asc}):
\begin{equation}
\inferrule{
  \performAna
    {\hGamma}
    {\zexp}
    {\htau}
    {\alpha}
    {\zexp'}
}{
  \performSyn
    {\hGamma}
    {\zexp : \htau}
    {\htau}
    {\alpha}
    {\zexp' : \htau}
    {\htau}
}
\end{equation}


When the cursor is in the type position of an ascription, we must re-check the ascribed expression because the cursor erasure might have changed (in practice, one would optimize this check to only occur if the cursor erasure did change):
\begin{equation}\label{rule:zipper-asc}
\inferrule{
  \performTyp{\ztau}{\alpha}{\ztau'}\\
  \hana{\hGamma}{\hexp}{\removeSel{\ztau'}}
}{
  \performSyn
    {\hGamma}
    {\hexp : \ztau}
    {\removeSel{\ztau}}
    {\alpha}
    {\hexp : \ztau'}
    {\removeSel{\ztau'}}
}
\end{equation}


When the cursor is in the function position of an application, the rule mirrors Rule (\ref{rule:syn-ap}):
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau_2}\\
    \performSyn
      {\hGamma}
      {\zexp}
      {\htau_2}
      {\alpha}
      {\zexp'}
      {\htau_3}\\\\
    \arrmatch{\htau_3}{\tarr{\htau_4}{\htau_5}}\\
    \hana{\hGamma}{\hexp}{\htau_4}
  }{
    \performSyn
      {\hGamma}
      {\hap{\zexp}{\hexp}}
      {\htau_1}
      {\alpha}
      {\hap{\zexp'}{\hexp}}
      {\htau_5}
  }
\end{equation}
% \begin{equation}
%   \inferrule{
%     \hsyn{\hGamma}{\removeSel{\zexp}}{\htau_2}\\
%     \performSyn
%       {\hGamma}
%       {\zexp}
%       {\htau_2}
%       {\alpha}
%       {\zexp'}
%       {\tehole}\\
%     \hana{\hGamma}{\hexp}{\tehole}
%   }{
%     \performSyn
%       {\hGamma}
%       {\hap{\zexp}{\hexp}}
%       {\htau_1}
%       {\alpha}
%       {\hap{\zexp'}{\hexp}}
%       {\tehole}
%   }
% \end{equation}

The situation is similar when the cursor is in argument position:
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\hexp}{\htau_2}\\
    \arrmatch{\htau_2}{\tarr{\htau_3}{\htau_4}}\\
    \performAna
      {\hGamma}
      {\zexp}
      {\htau_3}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hap{\hexp}{\zexp}}
      {\htau_1}
      {\alpha}
      {\hap{\hexp}{\zexp'}}
      {\htau_4}
  }
\end{equation}
% \begin{equation}
%   \inferrule{
%     \hsyn{\hGamma}{\hexp}{\tehole}\\
%     \performAna
%       {\hGamma}
%       {\zexp}
%       {\tehole}
%       {\alpha}
%       {\zexp'}
%   }{
%     \performSyn
%       {\hGamma}
%       {\hap{\hexp}{\zexp}}
%       {\tehole}
%       {\alpha}
%       {\hap{\hexp}{\zexp'}}
%       {\tehole}
%   }
% \end{equation}

The rules for the addition operator mirror Rule (\ref{rule:syn-plus}):
\begin{equation}
  \inferrule{
    \performAna
      {\hGamma}
      {\zexp}
      {\tnum}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hadd{\zexp}{\hexp}}
      {\tnum}
      {\alpha}
      {\hadd{\zexp'}{\hexp}}
      {\tnum}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performAna
      {\hGamma}
      {\zexp}
      {\tnum}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hadd{\hexp}{\zexp}}
      {\tnum}
      {\alpha}
      {\hadd{\hexp}{\zexp'}}
      {\tnum}
  }
\end{equation}

Finally, if the cursor is inside a non-empty hole, the relevant zipper rule mirrors Rule (\ref{rule:syn-ehole}):
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau}\\
    \performSyn
      {\hGamma}
      {\zexp}
      {\htau}
      {\alpha}
      {\zexp'}
      {\htau'}\\
  }{
    \performSyn
      {\hGamma}
      {\hhole{\zexp}}
      {\tehole}
      {\alpha}
      {\hhole{\zexp'}}
      {\tehole}
  }
\end{equation}
% \begin{equation}
%   \inferrule{
%     \hsyn{\hGamma}{\removeSel{\zexp}}{\htau}\\
%     \performSyn
%       {\hGamma}
%       {\zexp}
%       {\htau}
%       {\alpha}
%       {\zwsel{\hehole}}
%       {\tehole}\\
%   }{
%     \performSyn
%       {\hGamma}
%       {\hhole{\zexp}}
%       {\tehole}
%       {\alpha}
%       {\zwsel{\hehole}}
%       {\tehole}
%   }
% \end{equation}

Theorem \ref{thrm:actsafe} directly checks the correctness of these rules. Moreover, the zipper rules arise ubiquitously in derivations of edit steps, so the proofs of the other ``check'' theorems, e.g. Reachability and Constructability, serve as a check that none of these rules have been missed.
\end{subequations}
