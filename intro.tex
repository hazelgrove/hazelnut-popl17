% !TEX root = hazelnut-popl17.tex

Programmers typically construct and manipulate well-typed expressions only
indirectly, by editing text that is first parsed according to a textual
syntax and then typechecked according to a static semantics. This
indirection has practical benefits, to be sure -- text editors and other
text-based tools benefit from decades of development effort -- but it also
introduces some fundamental complexity into the programming process.

First, it requires that programmers learn the subtleties of the textual
syntax (e.g. the precedence of the various forms.) This can be particularly
challenging for novices \cite{Altadmri:2015:MCI:2676723.2677258}.

The fact that not every sequence of characters corresponds to a meaningful
program also complicates matters for tool designers. In particular, program
editors must contend with meaningless text on a regular basis. In a dataset
analyzed by Yoon and Myers consisting of 1460 hours of edit logs, 44.2\% of
edit states were syntactically malformed \cite{6883030}. Some additional
percentage of edit states were well-formed but ill-typed (the dataset did
not contain enough information to determine the exact percentage.)  Some of
these meaningless edit states arose because the programmer was in the midst
of a sequence of edits that left the edit state transiently meaningless,
while others arose because the programmer made a logical mistake. Because
the language definitions is silent about these edit states, it is difficult
to design useful editor services, e.g. syntax
highlighting~\cite{sarkar2015impact}, type-aware code
completion~\cite{Mooty:2010:CCC:1915084.1916348,Omar:2012:ACC:2337223.2337324},
and refactoring support \cite{mens2004survey}. Editors must either disable
these editor services when they encounter meaningless edit states or
develop \emph{ad hoc} heuristics, which can be misleading.

These complications have motivated a long line of research
into \emph{structure editors}, i.e. program editors where every edit state
is a program structure.

Most structure editors are \emph{syntactic structure editors}, i.e. the
edit state is a syntax tree with \emph{holes} that stand for branches of
the tree that have yet to be constructed, and the edit actions are
context-free tree transformations. For example, Scratch is a syntactic
structure editor that has achieved success as a tool for teaching children
how to program \cite{Resnick:2009:SP:1592761.1592779}.

The Scratch language has a trivial static semantics, but researchers have
also designed syntactic structure editors for languages with a non-trivial
static semantics. For example, \texttt{mbeddr} is an editor for a C-like
language \cite{voelter_mbeddr:_2012}, TouchDevelop is an editor for an
object-oriented language \cite{tillmann_touchdevelop:_2011} and Lamdu is an
editor for a functional language similar to Haskell \cite{lamdu}. Each of
these editors presents an innovative user interface, but the non-trivial
type and binding structure of the underlying language complicates its
design. The reason is that a syntactic structure editor does not guarantee
that every edit state is statically meaningful -- only that it is
syntactically well-formed. As in textual program editors, these syntactic
structure editors must either disable key editor services when they
encounter meaningless edit states or deploy \emph{ad hoc} heuristics.


This paper develops a principled solution to this problem. We introduce
Hazelnut, a \emph{typed structure editor} based on a bidirectionally typed
lambda calculus extended to assign static meaning to expressions and types
with {holes}, which we call \textbf{H-expressions}
and \textbf{H-types}. Hazelnut's formal \emph{action semantics} maintains
the invariant that every edit state is a statically meaningful
(i.e. well-typed) H-expression with a single superimposed \emph{cursor}. We
call H-expressions and H-types with a cursor \textbf{Z-expressions}
and \textbf{Z-types} (so prefixed because our encoding follows
Huet's \emph{zipper} pattern \cite{JFP::Huet1997}.)

Na\"ively, enforcing an injunction on ill-typed edit states would force
programmers to construct programs in a rigid ``outside-in'' manner. For
example, the programmer would often need to construct the outer function
application form before identifying the intended function. To address this
problem, Hazelnut leaves newly constructed expressions \emph{inside} a hole
if the expression's type is inconsistent with the expected type. This
meaningfully defers the type consistency check until the expression inside
the hole is \emph{finished}. In other words, holes appear both at the
leaves and at the internal nodes of an H-expression that remain under
construction.

The remainder of this paper is organized as follows:
\begin{itemize}[itemsep=0px,partopsep=2px,topsep=2px]
  \item We begin in Sec.  \ref{sec:example} with two examples of edit
    sequences to develop the reader's intuitions.

  \item We then give a detailed overview of Hazelnut's semantics and
  metatheory, and our mechanization in the Agda proof assistant, in
  Sec.  \ref{sec:hazel}.

  \item Hazelnut is a {foundational} calculus, i.e. a calculus that
  language and editor designers are expected to extend with higher level
  constructs. We extend Hazelnut with simple sum types in
  Sec.  \ref{sec:extending} to demonstrate how Hazelnut's rich metatheory
  guides such a development.

  \item In Sec.  \ref{sec:impl}, we briefly describe how Hazelnut's action
  semantics lends itself to efficient implementation as a functional
  reactive program. Our reference implementation is written
  using \lstinline{js_of_ocaml} and the OCaml \lstinline{React} library.

  \item In Sec.  \ref{sec:rw}, we summarize related work. In particular,
  much of the technical machinery needed to handle type holes coincides
  with machinery developed in the study of gradual type systems. Similarly,
  expression holes can be interpreted as the closures of contextual modal
  type theory, which, by its correspondence with contextual modal logic,
  lays logical foundations beneath our work.

  \item We conclude in Sec.  \ref{sec:future} by summarizing our vision of
  a principled science of structure editor design rooted in type theory,
  and suggest a number of future directions.
\end{itemize}
The supplemental material includes 1) a typeset listing of Hazelnut's rules
in definitional order; 2) the formalization of Hazelnut in Agda; and 3) our
reference implementation of Hazelnut, both in source form and pre-compiled
to JavaScript for use in a web browser.
