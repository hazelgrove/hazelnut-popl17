% !TEX root = hazelnut-popl17.tex

%% Programs (and, by the Curry-Howard correspondence, proofs) are rich
%% inductive structures. This fact is well understood amongst researchers
%% and experienced programmers, but still somewhat obscure amongst
%% programmers at large because programmers normally construct and interact
%% with programs only indirectly, e.g. using a text editor composed with a
%% parser.

%% There are some benefits to this approach, to be sure, but the structural
%% mismatch between programs and their textual representations also imposes
%% various burdens.  For example, the primitive edit actions available in a
%% text editor (e.g. inserting or deleting a character or word) do not
%% always correspond to sensible structural transformations.

% spj: describe the problem; state our contributions; STOP. one page max.

% When constructing a program or proof in a language with rich type
% structure, skilled programmers generally follow a \emph{type discipline}
% where they first determine the type of the expression that they are
% constructing in order to constrain the mental search space that they are
% operating within.

% For example, if the programmer knows that an expression of type
% $\tarr{\tnum}{\tnum}$ is needed, then it is often the case (though, of course, not
% necessarily the case) that the expression will take the form $$\hlam{\mathit{x}}{e}$$
% for some variable $x$ and function body $e$. If the programmer chooses this
% form, then after picking a suitable variable name, her focus will be on
% constructing a suitable body, $e$. Following the type discipline, $e$ must
% be of type $\tnum$, and so this process can begin anew.

% The problem is that when using a text
% editor to construct a program, it is easy, and indeed necessary, to deviate from this disciplined process.  Rather, text editors operate on sequences of
% characters (i.e. \emph{text}.) 

%Although programs can be represented as text, most text does not correspond to a syntactically well-formed and semantically well-defined program. 

Every day, programmers use text-based tools to construct and manipulate programs.  
These programs are written in languages which are defined by a textual syntax. 
While textual syntax has proved to have practical utility, it also introduces some fundamental complexity into the programming process.

%Doesn't really start out with a bang, IMHO. I like to start papers out with a "big" problem.
%Most programming languages define a textual syntax. This allows programmers to use text editors and other standard text-based tools to construct and manipulate programs. While this is of substantial practical utility, it also introduces some fundamental complexity into the programming process. 

Cognitively, it requires that programmers understand the subtleties of text parsing (e.g. the relative precedence of the various forms.) This can be particularly challenging for novice and end-user programmers.
One study~\cite{Altadmri:2015:MCI:2676723.2677258} of novice programmer error found that the most common of all errors was an syntactic error, specifically unbalanced parenthesis.
% Too much detail? 

It also complicates matters for tool designers because they might be confronted with text that does not correspond to a well-formed, meaningful program.
By analyzing the same data set used in~\cite{6883030}, which contains 1,460 hours of fine-grained code editing logs collected from 21 programmers, we found that 44.2\% of the code edits resulted in syntactically malformed state of the source code.
%\todo{mention YoungSeok's data here}. 
These malformed states could be errors, but they also may be because the programmer is in the midst of a sequence of edit actions that leaves the text temporarily malformed or ill-typed.
%, or because the programmer has made a mistake. 
The language definition is silent about these situations, so it is difficult for tools to help programmers determine and execute a corrective course of action (e.g. by providing syntax highlighting~\cite{sarkar2015impact} and semantics-aware code completion services~\cite{Mooty:2010:CCC:1915084.1916348}.)

Some editors have developed \emph{ad hoc} workarounds for this problem, e.g. they might attempt to insert closing delimiters automatically, use whitespace to guess where a construct is likely to end, or recover from a type error by pretending that the type was as expected (if, indeed, an expected type can be determined.\todo{citations?}) These heuristic methods are imperfect, complex and sometimes misleading.

% stuck editing a representation of the program instead of the structures
% themselves. The editor does not restrict what the programmer may do: you
% can delete characters that belong, insert ones that don't, forget things
% that were needed, and so. There's nothing stopping us from accidentally
% writing $$\lambda \mathit{x:num}.\mathit{(x,x)}$$ even though it's obvious
% that building a pair can't hope to form a natural number.

% The type structure of the language makes this sort of error obvious: it's
% not that you're adding characters that make your program incorrect, or even
% malformed; you're adding characters that can't possibly create a structure
% you want because of the type. Simply put, the primitive operations
% available in text editors do not always correspond to sensible
% transformations on the structure of the program.
One attempt to solve this problem has been \emph{Structure editors},
where every edit action leaves the program being manipulated in a 
structurally well-formed state.\footnote{In addition to eliminating malformed edit states, it is also often promised that programs can be written more quickly using a structure editor. However, we will not discuss such ``edit costs'' here, because they depend on particular implementation details, e.g. whether a keyboard or a mouse is in use.} 
%Scratch etc. for novices. mbeddr for pros. Lamdu and Unison ongoing efforts with a functional foundation. We give other examples of notable structure editors in Sec. \ref{sec:rw}.\todo{revise}

However, these syntactically correct states can be semantically meaningless (i.e. undefined), because the language definitions generally only give meaning to complete, well-typed terms. (e.g., when a branching element is introduced, the program does not become semantically correct until both branches are complete)
This makes it difficult for humans and tools to reason about types and binding during the development process, even when using a structure editor.
Similar to text editors, structure editors also can develop workarounds to try to help users, but these efforts can only extend so far, because of the underlying language definition.
%Some structure editors attempt stuff, but it is not clear what invariants are being maintained (e.g. Unison ; Scratch seems not to allow literals of the wrong type, but variables are not typed.)\todo{revise} %More sophisticated semantic reasoning principles thus remain .

%% TODO: some sort of transition that talks about how you still don't have
%% semantic reasoning principles because you can be left in a semantically
%% ill-defined state

%\todo{revise remainder of intro}

In this paper, we present a minimal structure editor, Hazelnut,  defined in the type-theoretic style (i.e. Hazelnut is a \emph{structure editor calculus}). 
By defining \emph{holes} as a language construct, for both expressions as types, Hazelnut enables type-aware actions that always leave the program in both a structurally and semantically well-defined state. 
%In Hazelnut, expressions and types with \emph{holes} have a well-defined static semantics. Edit actions are type-aware and leave the program in both a structurally and semantically well-defined state. 
In fact, edit actions maintain an even stronger invariant -- when acting on an expression whose type is determined by its surroundings (e.g. an expression in function argument position), only edit actions consistent with that type are permitted (we will formally state this invariant in Sec. \ref{sec:actions}.) This does not imply that programs need to be constructed in a strictly outside-in manner, however, because an expression that has a type that is not yet consistent with its surroundings will automatically be put into a {hole} that defers consistency analysis until the hole is \emph{finished}.

By keeping the program in both a structurally and semantically well-defined state at all times, Hazelnut allows users to avoid premature commitment~\cite{green1996usability}.  
By inserting a hole, the user can leave certain parts of the program unfinished, \todo{What is the best word to define this concept?  In progress, unfinished, incomple?} and yet still in a well defined type state. 
This also enables progressive evaluation~\cite{green1996usability}, because unfinished solutions are also are well-defined at all times, thus enabling tools to provide evaluation of unfinished solutions.
 



\todo{Talk about dynamics.}

The remainder of the paper is organized as follows:
\begin{itemize}
  \item We begin with an example to develop the reader's intuitions in Section
    \ref{sec:example}.

  \item We then formally define Hazelnut in Section \ref{sec:hazel} and state the important metatheoretic properties.
  \item Dynamics \ref{sec:dynamics}

  \item In Section \ref{sec:mech}, we describe our ongoing effort to formalize the semantics and metatheory of Hazelnut in Agda.

  \item In Section \ref{sec:impl}, we describe our ongoing effort to implement Hazelnut in a web browser, using a functional reactive model for user interaction.
  \item In Section \ref{sec:rw}, we give an overview of related work.
  \item We conclude in Section \ref{sec:future} by describing our vision for this work going 
    forward.
\end{itemize}
