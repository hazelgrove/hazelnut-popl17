% !TEX root = hazelnut-popl17.tex
\newcounter{sumtypedef}
\stepcounter{equation}
\renewcommand{\thesumtypedef}{\theequation\alph{sumtypedef}}

\newcommand{\Define}[1]{(\refstepcounter{sumtypedef}\thesumtypedef\label{#1})}

In this section, we will conservatively extend Hazelnut with binary {sum
types} to demonstrate how the rules and the rich metatheory developed in
the previous section serve to guide and constrain this and other such
efforts.

\paragraph{Syntax.}
%
The first step is to extend the syntax of H-types and H-expressions
with the familiar forms \cite{pfpl}:\vspace{-3px}
\begin{grammar}
\textsf{HTyp} & $\htau$ & \bnfas & $\cdots \bnfalt \tsum{\htau}{\htau}$
\\
\textsf{HExp} & $\hexp$ & \bnfas & $\cdots
\bnfalt \hinj{i}{\hexp}
\bnfalt \hcase{\hexp}{x}{\hexp}{y}{\hexp}$
\end{grammar}\vspace{-3px}
Recall that binary sum types introduce a new type-level connective,
$\htau_1 + \htau_2$. The introductory forms are the \emph{injections},
$\hinj{i}{\hexp}$; here, we consider only binary sums, so $i\in\{1,2\}$.
The elimination form is case
analysis,~$\hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2}$.

\begin{figure}
{
\judgbox{\tcompat{\htau_1}{\htau_2}}{(Additional type consistency rule:)}
\begin{equation}
  \inferrule{
    \tcompat{\htau_1}{\htau_1'}
    \\
    \tcompat{\htau_2}{\htau_2'}
    }
   {\tcompat{\htau_1 + \htau_2}{\htau_1' + \htau_2'}}
\end{equation}

\judgbox{\sumhasmatched{\htau}{\htau_1+\htau_2}}{$\htau$ has matched sum type $\htau_1+\htau_2$}
\begin{subequations}
\begin{minipage}{.5\linewidth}
\begin{equation}
\inferrule{ }
{\sumhasmatched{\htau_1 + \htau_2}{\htau_1 + \htau_2}}
\end{equation}
\end{minipage}
\begin{minipage}{.5\linewidth}
\begin{equation}
\inferrule{ }
{\sumhasmatched{\hehole}{\hehole + \hehole}}
\end{equation}
\end{minipage}
\end{subequations}

\vspace{3px}
\judgbox{\hana{\hGamma}{\hexp}{\htau}}{(Additional type analysis rules:)}
\begin{subequations}
\begin{equation}
\inferrule{
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}\\
  \hana{ \hGamma }{ \hexp }{ \htau_i }
}
{ \hana{ \hGamma }{ \hinj{i}{\hexp} }{ \htau_{+} } }~\text{$(i \in \{1, 2\})$}
\end{equation}
\begin{equation}
\inferrule%{\Define{ana-case}}
{ \hsyn{ \hGamma }{ \hexp }{ \htau_{+} }
  \\
  \sumhasmatched{\htau_{+}}{\tsum{\htau_1}{\htau_2}}
  \\\\
  \hana{ \hGamma, x:\htau_1 }{ \hexp_1 }{ \htau }
  \\
  \hana{ \hGamma, y:\htau_2 }{ \hexp_2 }{ \htau }
}
{ \hana{ \hGamma }{ \hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2} }{ \htau } }
\end{equation}
\end{subequations}
\caption{The statics of sums.}
\label{fig:sum-statics}
\vspace{15px}
\judgbox{\performTyp{\ztau}{\alpha}{\ztau}}{(Additional type actions:)}\vspace{-5px}
\begin{subequations}
\begin{equation}\label{rule:construct-sum}
  \inferrule{ }
{
  \performTyp{\zwsel{\htau}}{\aConstruct{\fsum}}
             {\tsum{{\htau}}{\zwsel{\hehole}}}
}
\end{equation}
\noindent\begin{minipage}{.5\linewidth}
 \begin{equation}\label{rule:zipper-sum-left}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      {\ztau} + {\htau}
    }{
      \alpha
    }{
      {\ztau'} + {\htau}
    }
  }
\end{equation}\end{minipage}\begin{minipage}{.5\linewidth}
\begin{equation}\label{rule:zipper-sum-right}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      {\htau} + {\ztau}
    }{
      \alpha
    }{
      {\htau} + {\ztau'}
    }
  }
\end{equation}
\end{minipage}
\end{subequations}
\judgbox{\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}}
{(Additional analytic actions:)}
\begin{subequations}
\begin{equation}\label{rule:performAna-inj-1}
  \inferrule{ \sumhasmatched{\htau_{+}}{\tsum{\htau_{1}}{\htau_{2}}} }
  {
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau_{+}}
              {\aConstruct{\finj{i}}}
              {\hinj{i}{\zwsel{\hehole}}}
  }
\end{equation}
\begin{equation}\label{rule:performAna-inj-2}
  \inferrule{ \tincompat{\htau}{ \tsum{\hehole}{\hehole} } }
        {
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstruct{\finj{i}}}
              {\hhole{
                  \hinj{i}{\hehole}
                  : \zwsel{\hehole} + \hehole
              }}
        }
\end{equation}
\begin{equation}\label{rule:performAna-case}
  \inferrule{ }{
  \performAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstruct{\fcase{x}{y}}}
              {\hcase{\zwsel{\hehole}}{x}{\hehole}{y}{\hehole}}
  }
\end{equation}
\begin{equation}\label{rule:zipper-inj}
%% Inj -- Editing injected expression
\inferrule
{
  \sumhasmatched{\htau_{+}}{\htau_1+\htau_2}\\
  \performAna{\hGamma}{\zexp}{\htau_i}{\alpha}{\zexp'}
}{
  \performAna
  {\hGamma}
  {\hinj{i}{\zexp }}
  {\htau_{+}}
  {\alpha}
  {\hinj{i}{\zexp' }}
}~\text{$(i\in\{1,2\})$}
\end{equation}
\begin{equation}\label{rule:zipper-case-1}
%% Case -- Editing scrutinee
\inferrule
{
  \hsyn
  {\hGamma}
  {\removeSel{\zexp}}
  {\htau_0}
  \\\\
  \performSyn
  {\hGamma}
  {\zexp}
  {\htau_0}
  {\alpha}
  {\zexp'}
  {\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \hana{\hGamma, x:\htau_1}{\hexp_1}{\htau}
  \\
  \hana{\hGamma, y:\htau_2}{\hexp_2}{\htau}
}{
  \performAna
  {\hGamma}
  {\hcase{\zexp }{x}{\hexp_1}{y}{\hexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\zexp'}{x}{\hexp_1}{y}{\hexp_2}}
}
\end{equation}
\begin{equation}\label{rule:zipper-case-2}
%% Case -- Editing first branch arm
\inferrule
{
  \hsyn{\hGamma}{\hexp}{\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \performAna{\hGamma, x:\htau_1}{\zexp_1}{\htau}{\alpha}{\zexp_1'}
  \\
  \hana{\hGamma, y:\htau_2}{\hexp_2}{\htau}
}{
  \performAna
  {\hGamma}
  {\hcase{\hexp}{x}{\zexp_1}{y}{\hexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\hexp}{x}{\zexp_1'}{y}{\hexp_2}}
}
\end{equation}
\begin{equation}\label{rule:zipper-case-3}
%% Case -- Editing second branch arm
\inferrule
{
  \hsyn{\hGamma}{\hexp}{\htau_{+}}
  \\
  \sumhasmatched{\htau_{+}}{\htau_1 + \htau_2}
  \\\\
  \hana{\hGamma, x:\htau_1}{\hexp_1}{\htau}
  \\
  \performAna{\hGamma, y:\htau_2}{\zexp_2}{\htau}{\alpha}{\zexp_2'}
}{
  \performAna
  {\hGamma}
  {\hcase{\hexp}{x}{\hexp_1}{y}{\zexp_2}}
  {\htau}
  {\alpha}
  {\hcase{\hexp}{x}{\hexp_1}{y}{\zexp_2'}}
}
\end{equation}
% }
\end{subequations}
\judgbox{\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}}
{(Additional synthetic actions:)}\vspace{-5px}
\begin{equation}\label{rule:performSyn-inj}
%% Case -- Editing second branch arm
\inferrule
{ }{
  \performSyn
  {\hGamma}
  {\zwsel{\hhole{}}}
  {\htau}
  {\aConstruct{\finj{i}}}
  {\hinj{i}{{\hhole{}}} : \zwsel{\tehole} + \tehole}
  {\tehole + \tehole}
}
\end{equation}
\caption{The construction \& zipper action rules for sums.}
\label{fig:sum-action}
}
\end{figure}

\begin{figure}
\judgbox{\performMove{\ztau}{\aMove{\delta}}{\ztau'}}{(Additional type movement rules:)}
\begin{displaymath}
\begin{array}{@{}rcl}
  \TABperformMove
      {\zwsel{\tsum{\htau_1}{\htau_2}}}
      {\aMove{\dChild}}
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
  \\
  \TABperformMove
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
      {\aMove{\dNext}}
      {      {\tsum{{\htau_1}}{\zwsel{\htau_2}}}}
  \\
  \TABperformMove
      {      {\tsum{\zwsel{\htau_1}}{\htau_2}}}
      {\aMove{\dParent}}
      {\zwsel{\tsum{{\htau_1}}{{\htau_2}}}}
  \\
  \TABperformMove
      {      {\tsum{{\htau_1}}{{\zwsel{\htau_2}}}}}
      {\aMove{\dParent}}
      {\zwsel{\tsum{{\htau_1}}{\htau_2}}}
  \\[2mm]
\end{array}
\end{displaymath}
\judgbox{\performMove{\zexp}{\aMove{\delta}}{\zexp'}}{(Additional expression movement rules:)}
\begin{displaymath}
\begin{array}{@{}rcl}
  \TABperformMove
      {\zwsel{\hinj{i}{\hexp}}}
      {\aMove{\dChild}}
      {\hinj{i}{\zwsel{\hexp}}}
  \\
  \TABperformMove
      {\hinj{i}{\zwsel{\hexp}}}
      {\aMove{\dParent}}
      {\zwsel{\hinj{i}{\hexp}}}
  \\[2mm]
  \TABperformMove
      {\zwsel{\hcase{\hexp}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dChild}}
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dNext}}
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
      {\aMove{\dNext}}
      {      {\hcase{{\hexp}}{x}{{\hexp_1}}{y}{\zwsel{\hexp_2}}}}
  \\
  \TABperformMove
      {      {\hcase{\zwsel{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\zwsel{\hexp_1}}{y}{\hexp_2}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
  \\
  \TABperformMove
      {      {\hcase{{\hexp}}{x}{\hexp_1}{y}{\zwsel{\hexp_2}}}}
      {\aMove{\dParent}}
      {\zwsel{\hcase{{\hexp}}{x}{\hexp_1}{y}{\hexp_2}}}
\end{array}
\end{displaymath}
\caption{Movement actions for sums.}
\label{fig:sum-move}
\end{figure}

Next, we must correspondingly extend the syntax of Z-types and
Z-expressions, following Huet's zipper pattern \cite{JFP::Huet1997}:
\begin{grammar}
\textsf{ZTyp} & $\ztau$ & \bnfas & $\cdots \bnfalt \tsum{\ztau}{\htau} \bnfalt \tsum{\htau}{\ztau}$
\\
\textsf{ZExp} & $\zexp$ & \bnfas & $\cdots
\bnfalt \hinj{i}{\zexp}
\bnfalt \hcase{\zexp}{x}{\hexp}{y}{\hexp}$
\\
&& $\bnfalt$ & $\hcase{\hexp}{x}{\zexp}{y}{\hexp}
\bnfalt\hcase{\hexp}{x}{\hexp}{y}{\zexp}$
\end{grammar}
Notice that for each H-type or H-expression form of arity $n$, there are
$n$ corresponding Z-type or Z-expression forms, each of which has a single
``hatted'' subterm. The remaining subterms are ``dotted''. We must also
extend the definition of cursor erasure, e.g. for types:
\begin{align*}
\removeSel{(\ztau + \htau)} & = \removeSel{\ztau} + \htau\\
\removeSel{(\htau + \ztau)} & = \htau + \removeSel{\ztau}
\end{align*}
The rules for Z-expressions are analogous:
\begin{align*}
\removeSel{\hinj{i}{\zexp}} & = \hinj{i}{\removeSel{\zexp}}\\
\removeSel{\hcase{\zexp}{x}{\hexp_1}{y}{\hexp_2}} & = \hcase{\removeSel{\zexp}}{x}{\hexp_1}{y}{\hexp_2}\\
\removeSel{\hcase{\hexp}{x}{\zexp_1}{y}{\hexp_2}} & = \hcase{\hexp}{x}{\removeSel{\zexp_1}}{y}{\hexp_2}\\
\removeSel{\hcase{\hexp}{x}{\hexp_1}{y}{\zexp_2}} & = \hcase{\hexp}{x}{\hexp_1}{y}{\removeSel{\zexp_2}}
\end{align*}

Finally, we must extend the syntax of shapes:
\begin{grammar}
\textsf{Shape} & $\psi$ & \bnfas & $\cdots \bnfalt \fsum \bnfalt \finj{i} \bnfalt \fcase{x}{y}$
\end{grammar}
Notice that for each H-type or H-expression form, there is a corresponding
shape. The injection form had a formal parameter, $i$, so the corresponding
shape takes a corresponding argument (like $\fnumlit{n}$.) The case form
included two variable binders, so the corresponding shape takes two
variable arguments (like $\flam{x}$.)



\paragraph{Statics.}
We can now move on to the static semantics.

First, we must extend the type consistency relation as shown in
Figure \ref{fig:sum-statics}, following the example of covariant type
consistency rule for arrow types in
Figure \ref{fig:type-consistency}. Similarly, we need a notion of
a \emph{matched sum type} spiritually analogous to the notion of a matched
arrow type defined in Figure \ref{fig:type-consistency}.

The type analysis rules shown in Figure \ref{fig:sum-statics} are
essentially standard, differing only in that instead of immediately
requiring that a type be of the form $\htau_1 + \htau_2$, we use the
matched sum type judgement. We combine the two injection rules for
concision and define only a type analysis rule for the case form for
simplicity (see \cite{DBLP:conf/popl/CiminiS16} for additional machinery
that would be necessary for a synthetic rule.)


\paragraph{Action Semantics.}
Figures~\ref{fig:sum-action} and \ref{fig:sum-move} extend Hazelnut's
action semantics to support bidirectionally typed structure editing with sums.
%

Rule (\ref{rule:construct-sum}), the construction rule for sum types, and
Rules (\ref{rule:zipper-sum-left})-(\ref{rule:zipper-sum-right}), the
zipper rules for sum types, follow the corresponding rules for arrow
types. Were we to have missed any of these, the first clause of
Theorem \ref{thrm:constructability}, i.e. Constructability, would not be
conserved.

Rule (\ref{rule:performAna-inj-1}) constructs an injection when the type
provided for analysis has a matched sum type. This is analogous to Rule
(\ref{rule:performAna-lam-1}) for lambdas. Rule
(\ref{rule:performAna-inj-2}) constructs an injection when the type
provided for analysis is not consistent with sum types. This is analogous
to Rule (\ref{rule:performAna-construct-lam-2}) for lambdas. Rule
(\ref{rule:performAna-case}) is a straightforward rule for constructing
case expressions in empty holes. Rules
(\ref{rule:zipper-inj})-(\ref{rule:zipper-case-3}) are the zipper cases,
which follow the structure of the statics. Finally, we also define a single
new synthetic action rule, Rule (\ref{rule:performSyn-inj}), which allows
for the construction of an injection in synthetic position, with automatic
insertion of an ascription. This is analogous to Rule
(\ref{r:conelamhole}). If we had defined any of these rules incorrectly,
the Sensibility Theorem (Theorem \ref{thrm:actsafe}) would not be
conserved. Had we forgotten the analytic rules, the Constructability
Theorem (Theorem \ref{thrm:constructability}) would not be conserved.

Figure \ref{fig:sum-move} gives the relevant movement axioms. For concision
and clarity, we write these axioms in tabular form. Had we made a mistake
in any of these rules, the Movement Erasure Invariance theorem
(Theorem \ref{lemma:movement-erasure}) would not be conserved. Had we
forgotten any of these rules, the Reachability Theorem
(Theorem \ref{thrm:reachability}) would not be conserved.

\iffalse
\begin{displaymath}
\begin{array}{@{}r@{~}l@{~~~}c@{~~~}ll@{~~}}
  %\hline
  \multicolumn{5}{l}{\textbf{Type Construction Actions for Sum Type}:}
  \\
  \TABperformTyp{\zwsel{\hehole}}{\aConstructx{\fsum}}
  {\tsum{\zwsel{\hehole}}{\hehole}}
  \\[3mm]
  \multicolumn{5}{l}{\textbf{Analytical Construction Actions for Sum Type}:}
  \\
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\tsum{\hehole}{\hehole}}
              {\aConstructx{\finj{i}}}
              {\hinj{i}{\zwsel{\hehole}}}
  \\
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\htau, \tincompat{\htau}{ \tsum{\hehole}{\hehole} }}
              {\aConstructx{\finj{i}}}
              {\hhole{\hinj{i}{\zwsel{\hehole}}}}
  \\
  \TABperformAna{\hGamma}{\zwsel{\hehole}}
              {\htau}
              {\aConstructx{\fcase{x}{y}}}
              {\hcase{\zwsel{\hehole}}{x}{\hehole}{y}{\hehole}}
\end{array}
\end{displaymath}
\fi
