% !TEX root = hazelnut-popl17.tex

The previous section introduced Hazelnut by example. In this section, we
systematically define the following structures:
\begin{itemize}[itemsep=0px,partopsep=2px,topsep=2px]
\item \textbf{H-types} and \textbf{H-expressions} (Sec. \ref{sec:holes}),
  which are types and expressions with {holes}. H-types classify
  H-expressions according to Hazelnut's \textbf{bidirectional static
    semantics}.

\item \textbf{Z-types} and \textbf{Z-expressions} (Sec. \ref{sec:cursors}),
  which superimpose\- a \emph{cursor} onto H-types and H-expressions,
  respectively (following Huet's \emph{zipper pattern}
  \cite{JFP::Huet1997}.) Every Z-type (resp. Z-expression) corresponds to
  an H-type (resp. H-expression) by \emph{cursor erasure}.

\item \textbf{Actions} (Sec. \ref{sec:actions}), which act relative to the
  cursor according to Hazelnut's \textbf{bidirectional action
    semantics}. The action semantics enjoys a rich metatheory. Of
  particular note, the \emph{sensibility theorem} establishes that every
  edit state is well-typed after cursor erasure.
\end{itemize}

Our overview below omits certain ``uninteresting'' details. The supplement
includes the complete collection of rules, in definitional order. These
rules, along with the proofs of all of the metatheorems discussed in this section (and several omitted auxiliary lemmas), have been
mechanized using the Agda proof assistant \cite{norell:thesis} (discussed in Sec. \ref{sec:mech}.)

\subsection{H-types and H-expressions}\label{sec:holes}
Figure \ref{fig:hexp-syntax} defines the syntax of H-types, $\htau$, and
H-expressions, $\hexp$. Most forms correspond directly to those of the
simply typed lambda calculus (STLC) extended with a single base type,
$\tnum$, of numbers (cf. \cite{pfpl}.) The number expression corresponding
to the mathematical number $n$ is drawn $\hnum{n}$, and for simplicity, we
define only a single arithmetic operation, $\hadd{\hexp}{\hexp}$. The form
$\hexp : \htau$ is an explicit \emph{type ascription}. In addition to these standard forms, \emph{type holes} and \emph{empty
  expression holes} are both drawn $\hehole$ and \emph{non-empty expression
  holes} are drawn $\hhole{\hexp}$.
Types and expressions that contain no holes are \emph{complete types} and
\emph{complete expressions}, respectively.
%We do not, therefore, need to separately define the dynamics of complete expressions here (see, e.g., Harper \cite{pfpl}.) We will not develop a dynamics for incomplete expressions (but see Sec. \ref{sec:rw} for a discussion of this intriguing idea.)
%Formally, we can derive
%$\hcomplete{\htau}$ when $\htau$ is complete, and $\hcomplete{\hexp}$ when
%$\hexp$ is complete (see supplement.)

\begin{figure}[t]
$\arraycolsep=4pt\begin{array}{lllllll}
\mathsf{HTyp} & \htau & ::= &
  \tarr{\htau}{\htau} ~\vert~
  \tnum ~\vert~
  \tehole\\
\mathsf{HExp} & \hexp & ::= &
  x ~\vert~
  {\hlam{x}{\hexp}} ~\vert~
  \hap{\hexp}{\hexp} ~\vert~
  \hnum{n} ~\vert~
  \hadd{\hexp}{\hexp} ~\vert~
  \hexp : \htau ~\vert~
  \hehole ~\vert~
  \hhole{\hexp}
\end{array}$
\caption{Syntax of H-types and H-expressions. Metavariable $x$ ranges over variables and $n$ ranges over numerals.}
\label{fig:hexp-syntax}
\end{figure}


\begin{figure}
\fbox{$\hsyn{\hGamma}{\hexp}{\htau}$}~~\text{$\hexp$ synthesizes $\htau$}
\begin{subequations}
\begin{equation}\label{rule:syn-var}
\inferrule{ }{
  \hsyn{\hGamma, x : \htau}{x}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-ap}
\inferrule{
  \hsyn{\hGamma}{\hexp_1}{\htau_1}\\
  \arrmatch{\htau_1}{\tarr{\htau_2}{\htau}}\\
  \hana{\hGamma}{\hexp_2}{\htau_2}
}{
  \hsyn{\hGamma}{\hap{\hexp_1}{\hexp_2}}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-num}
\inferrule{ }{
  \hsyn{\hGamma}{\hnum{n}}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:syn-plus}
\inferrule{
  \hana{\hGamma}{\hexp_1}{\tnum}\\
  \hana{\hGamma}{\hexp_2}{\tnum}
}{
  \hsyn{\hGamma}{\hadd{\hexp_1}{\hexp_2}}{\tnum}
}
\end{equation}
\begin{equation}\label{rule:syn-asc}
\inferrule{
  \hana{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hexp : \htau}{\htau}
}
\end{equation}
\begin{equation}\label{rule:syn-ehole}
\inferrule{ }{
  \hsyn{\hGamma}{\hehole}{\tehole}
}
\end{equation}
\begin{equation}\label{rule:syn-hole}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau}
}{
  \hsyn{\hGamma}{\hhole{\hexp}}{\tehole}
}
\end{equation}
\end{subequations}
\fbox{$\hana{\hGamma}{\hexp}{\htau}$}~~\text{$\hexp$ analyzes against $\htau$}
\begin{subequations}
\begin{equation}\label{rule:syn-lam}
\inferrule{
  \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}\\
  \hana{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\htau}
}
\end{equation}
\begin{equation}\label{rule:ana-subsume}
\inferrule{
  \hsyn{\hGamma}{\hexp}{\htau'}\\
  \tcompat{\htau}{\htau'}
}{
  \hana{\hGamma}{\hexp}{\htau}
}
\end{equation}
\end{subequations}
\caption{H-type synthesis and analysis.}
\label{fig:ana-syn}
\end{figure}
\begin{figure}
\vspace{-1px}\noindent\fbox{$\tcompat{\htau}{\htau'}$}~~\text{$\htau$ and $\htau'$ are consistent}\vspace{-4px}
\begin{subequations}\label{eqns:consistency}
\begin{mathpar}
\inferrule{ }{
  \tcompat{\tehole}{\htau}
}
~~~~~
\inferrule{ }{
  \tcompat{\htau}{\tehole}
}
~~~~~
\inferrule{ }{
  \tcompat{\htau}{\htau}
}
~~~~~
\inferrule{
  \tcompat{\htau_1}{\htau_1'}\\
  \tcompat{\htau_2}{\htau_2'}
}{
  \tcompat{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1'}{\htau_2'}}
}~~~~\text{\hspace{-2px}(\ref*{eqns:consistency}a-d)}
\end{mathpar}
\end{subequations}
\noindent\fbox{$\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$}~~\text{$\htau$ has matched arrow type $\tarr{\htau_1}{\htau_2}$}\vspace{-4px}

\begin{subequations}
\begin{minipage}{0.43\linewidth}
\begin{equation}
\inferrule{ }{
  \arrmatch{\tehole}{\tarr{\tehole}{\tehole}}
}
\end{equation}
\end{minipage}
\begin{minipage}{0.55\linewidth}
\begin{equation}
\inferrule{ }{
  \arrmatch{\tarr{\htau_1}{\htau_2}}{\tarr{\htau_1}{\htau_2}}
}
\end{equation}
\end{minipage}
\end{subequations}
\caption{H-type consistency and matched arrow types.}
\label{fig:type-consistency}
\end{figure}

Hazelnut's static semantics is organized as a \emph{bidirectional type
  system}
\cite{Pierce:2000:LTI:345099.345100,DBLP:conf/icfp/DaviesP00,DBLP:conf/tldi/ChlipalaPH05,bidi-tutorial}
around the two mutually defined judgements in Figure
\ref{fig:ana-syn}. Derivations of the type analysis judgement, $\hana{\hGamma}{\hexp}{\htau}$,
establish that $\hexp$ can appear where an expression of type $\htau$ is
expected. Derivations of the type synthesis judgement,
$\hsyn{\hGamma}{\hexp}{\htau}$, synthesize (a.k.a. \emph{locally infer} \cite{Pierce:2000:LTI:345099.345100}) a type from $\hexp$. Type synthesis is
necessary in positions where an expected type is not available (e.g. at the
top level.) Algorithmically, the type is an ``input'' of the type analysis
judgement, but an ``output'' of the type synthesis judgement.  Making a
judgemental distinction between these two notions will be essential in our
action semantics (Sec. \ref{sec:actions}.)

If an expression is
able to synthesize a type, it can also be analyzed against that type, or
any other \emph{consistent} type, according to the \emph{subsumption rule},
Rule (\ref{rule:ana-subsume}).% Type analysis of every form other than the lambda form goes through subsumption.

The \emph{H-type consistency judgement}, $\tcompat{\htau}{\htau'}$, that
appears as a premise in the subsumption rule is a reflexive and symmetric
(but not transitive) relation between H-types defined judgementally in
Figure \ref{fig:type-consistency}. This relation coincides with equality
for complete H-types. Two incomplete H-types are consistent if they differ
only at positions where a hole appears in either type. The type hole is
therefore consistent with every type. This notion of H-type consistency
coincides with the notion of type consistency that Siek and Taha discovered
in their foundational work on gradual type systems, if we interpret the
type hole as the $?$ (i.e. unknown) type \cite{Siek06a}.

Typing contexts, $\hGamma$, map each variable $x \in
\domof{\hGamma}$ to an hypothesis $x : \htau$. We
identify contexts up to exchange and contraction and adopt the standard identification
convention for structures that differ only up to alpha-renaming of bound variables. All hypothetical judgements obey a standard weakening lemma. Rule (\ref{rule:syn-var}) establishes that variable expressions synthesize the hypothesized H-type, in the standard manner.

Rule (\ref{rule:syn-lam}) defines analysis for lambda abstractions,
$\hlam{x}{\hexp}$. There is no type synthesis rule that applies to this
form, so lambda abstractions can appear only in analytic position,
i.e. where an expected type is known.\footnote{It is possible to also
  define a ``half-annotated'' synthetic lambda form, $\lambda x{:}\tau.e$,
  but for simplicity, we leave it out \cite{DBLP:conf/tldi/ChlipalaPH05}.}
Rule (\ref{rule:syn-lam}) is not quite the standard rule, as reproduced below:
\begin{equation*}
\inferrule{
  \hana{\hGamma, x : \htau_1}{\hexp}{\htau_2}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\tarr{\htau_1}{\htau_2}}
}
\end{equation*}
The problem is that this standard rule alone leaves us unable to analyze
lambda abstractions against the type hole, because the type hole is not
immediately of the form $\tarr{\htau_1}{\htau_2}$. There are two plausible
solutions to this problem. One solution would be to define a second rule
specifically for this case:
\begin{equation*}
\inferrule{
  \hana{\hGamma, x : \tehole}{\hexp}{\tehole}
}{
  \hana{\hGamma}{\hlam{x}{\hexp}}{\tehole}
}
\end{equation*}
Instead, we combine these two possible rules into a single rule through the
simple auxiliary \emph{matched arrow type} judgement,
$\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$, defined in Figure
\ref{fig:type-consistency}. This judgement leaves arrow types alone and
assigns the type hole the matched arrow type $\tarr{\tehole}{\tehole}$. It
is easy to see that the two rules above are admissible by appeal to Rule
(\ref{rule:syn-lam}) and the matched arrow type judgement.  Encouragingly,
the matched arrow type judgement also arises in gradual type systems
\cite{DBLP:conf/popl/CiminiS16,DBLP:conf/popl/GarciaC15,DBLP:conf/popl/RastogiCH12}.

Rule (\ref{rule:syn-ap}) is again nearly the standard rule for function
application. It also makes use of the matched function type judgement to
combine what would otherwise need to be two rules for function application
-- one for when $e_1$ synthesizes an arrow type, and another for when $e_1$
synthesizes $\tehole$.

Rule (\ref{rule:syn-num}) states that numbers synthesize the $\tnum$
type. Rule (\ref{rule:syn-plus}) states that $\hexp_1 + \hexp_2$ behaves
like a function over numbers.

Rule (\ref{rule:syn-asc}) defines type synthesis of expressions of
ascription form, $\hexp : \htau$. This allows the programmer to explicitly state
a type for the ascribed expression to be analyzed against.



The rules described so far are sufficient to type complete
H-expressions. The two remaining rules give H-expressions with holes a
well-defined static semantics.

Rule (\ref{rule:syn-ehole}) states that the empty expression hole
synthesizes the type hole. Non-empty holes, which contain an H-expression that is ``under construction''
as described in Sec. \ref{sec:example}, also synthesize the hole type. According to Rule
(\ref{rule:syn-hole}), the enveloped expression must synthesize some (arbitrary) type. (We do not need non-empty type holes because every H-type is a valid classifier of H-expressions.)

Because the hole type is consistent with every type, expression holes can be analyzed against any type by subsumption. For example, it is instructive to derive the following:
\[\hana{incr : \tarr{\tnum}{\tnum}}{\hhole{incr}}{\tnum}\]


\subsection{Z-types and Z-expressions}\label{sec:cursors}
\newcommand{\cvert}{{\,{\vert}\,}}
\begin{figure}[t]
$\arraycolsep=2pt\begin{array}{lllllll}
\mathsf{ZTyp} & \ztau & ::= &
  \zwsel{\htau} \cvert
  \tarr{\ztau}{\htau} \cvert
  \tarr{\htau}{\ztau} \\
\mathsf{ZExp} & \zexp & ::= &
  \zwsel{\hexp} \cvert
  \hlam{x}{\zexp} \cvert
  \hap{\zexp}{\hexp} \cvert
  \hap{\hexp}{\zexp} \cvert
  \hadd{\zexp}{\hexp} \cvert
  \hadd{\hexp}{\zexp} \\
& & \cvert &
    \zexp : \htau \cvert
  \hexp : \ztau \cvert
  \hhole{\zexp}
\end{array}$
\caption{Syntax of Z-types and Z-expressions.}
\label{fig:zexp-syntax}
\end{figure}

Figure \ref{fig:zexp-syntax} defines the syntax of
Z-types, $\ztau$, and Z-expressions, $\zexp$. A Z-type (resp. Z-expression) represents an
H-type (resp. H-expression) with a single superimposed \emph{cursor}.

The only base cases in these inductive grammars are $\zwsel{\htau}$ and
$\zwsel{\hexp}$, which identify the H-type or H-expression that the cursor
is on. All of the other forms correspond to the recursive forms in the
syntax of H-types and H-expressions, and contain exactly one ``hatted''
subterm that identifies the subtree where the cursor will be found. Any
other sub-term is ``dotted'', i.e. it is either an H-type or
H-expression. Taken together, every Z-type and Z-expression contains
exactly one selected H-type or H-expression by construction. This can be
understood as an instance of Huet's \emph{zipper pattern}
\cite{JFP::Huet1997} (which, coincidentally, Huet encountered while
implementing a structure editor.)

We write $\removeSel{\ztau}$ for the H-type constructed by erasing the
cursor from $\ztau$, which we refer to as the \emph{cursor erasure} of
$\ztau$. This straightforward metafunction is defined as follows:
\begin{align*}
\removeSel{\zwsel{\htau}} & = \htau\\
\removeSel{\tarr{\ztau}{\htau}} & = \tarr{\removeSel{\ztau}}{\htau}\\
\removeSel{\tarr{\htau}{\ztau}} & = \tarr{\htau}{\removeSel{\ztau}}
\end{align*}

Similarly, we write $\removeSel{\zexp}$ for cursor erasure of $\zexp$. The definition of this metafunction is analogous, so we omit it
for concision.

This zipper structure is not the only way to model a cursor, though we have found it to be the most elegant for our present purposes. Another plausible strategy would be to formalize the notion of a relative path into an H-expression. This would then require defining the notion of consistency between a relative path and an H-expression, so we avoid it.

\subsection{Actions}\label{sec:actions}

We now arrive at the heart of Hazelnut: its \emph{bidirectional action
  semantics}.  Figure \ref{fig:action-syntax} defines the syntax of
\emph{actions}, $\alpha$, some of which involve \emph{directions},
$\delta$, and \emph{shapes}, $\psi$.

Expression actions are governed by two mutually defined judgements, 1) the
\emph{synthetic action judgement}:
\[
\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}
\]
and 2) \emph{the analytic action judgement}:
\[
\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}
\]

In some Z-expressions, the cursor is in a type ascription, so we also need
a \emph{type action judgement}:
\[
\performTyp{\ztau}{\alpha}{\ztau'}
\]

\subsubsection{Sensibility}


These judgements are governed by a critical
metatheorem, \emph{action sensibility} (or simply \emph{sensibility}):
\begin{theorem}[Action Sensibility]
  \label{thrm:actsafe} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ then
    $\hsyn{\hGamma}{\removeSel{\zexp'}}{\htau'}$.
  \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ then
    $\hana{\hGamma}{\removeSel{\zexp'}}{\htau}$.
  \end{enumerate}
\end{theorem}
\noindent In other words, if a Z-expression is
statically meaningful, i.e. its cursor erasure is well-typed, then
performing an action on it leaves the resulting Z-expression statically
meaningful. More specifically, the first clause of Theorem \ref{thrm:actsafe}
establishes that when an action is performed on a Z-expression whose cursor
erasure synthesizes an H-type, the result is a Z-expression whose cursor
erasure also synthesizes some (possibly different) H-type. The second
clause establishes that when an action is performed using the analytic
action judgement on an edit state whose cursor erasure analyzes against
some H-type, the result is a Z-expression whose cursor erasure also
analyzes against the same H-type.

This metatheorem deeply informs the design
of the rules, given starting in Sec. \ref{sec:action-subsumption}. Its
proof is by straightforward induction, so the
reader is encouraged to think about the relevant proof case when considering each action rule below.

No sensibility theorem is needed for the type action judgement because every syntactically well-formed type is meaningful in Hazelnut. (Adding type variables to the language would require defining both a type-level sensibility theorem and
type-level non-empty holes.)
\begin{figure}[t]
\hspace{-3px}$\arraycolsep=3pt\begin{array}{llcllll}
\mathsf{Action} & \alpha & ::= &
  \aMove{\delta} ~\vert~
  \aConstruct{\psi} ~\vert~
  \aDel ~\vert~
  \aFinish\\
\mathsf{Dir} & \delta & ::= &
  \dChildnm{n} ~\vert~
  \dParent\\
\mathsf{Shape} & \psi & ::= &
  \farr ~\vert~
  \fnum \\
& & \vert &
  \fasc ~\vert~
  \fvar{x} ~\vert~
  \flam{x} ~\vert~
  \fap ~\vert~
  % \farg ~\vert~
  \fnumlit{n} ~\vert~
  \fplus\\
& & \vert &
  {\color{gray}\fnehole}
\end{array}$
\caption{Syntax of actions.}
\label{fig:action-syntax}
\end{figure}

\subsubsection{Type Inconsistency}
In some of the rules below, we will need to supplement our definition of
type consistency from Figure \ref{fig:type-consistency} with a definition
of \emph{type inconsistency}, written $\tincompat{\htau}{\htau'}$. One can
define this notion either directly as the constructive negation of type
consistency, or as a separate inductively defined judgement with the following
key rule, which establishes that arrow types are inconsistent
with $\tnum$:
  \begin{equation*}
    \inferrule{ }{
      \tincompat{\tnum}{\tarr{\htau_1}{\htau_2}}
    }
  \end{equation*}
The mechanization proves that the judgemental definition of type
inconsistency is indeed the negation of type consistency.

\subsubsection{Action Subsumption}\label{sec:action-subsumption}

The action semantics includes a subsumption rule similar to the subsumption
rule, Rule (\ref{rule:ana-subsume}), in the statics:
\begin{equation}\label{rule:action-subsume}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau'}\\
    \performSyn{\hGamma}{\zexp}{\htau'}{\alpha}{\zexp'}{\htau''}\\
    \tcompat{\htau}{\htau''}
  }{
    \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}
  }
\end{equation}
In other words, if the cursor erasure of the edit state synthesizes a type, $\htau'$,
then we defer to the synthetic action judgement. The cursor erasure of the Z-expression resulting from performing the action $\alpha$ synthetically could have a different type, $\htau''$, so we must check that it is consistent with the type provided for analysis, $\htau$.
The case for Rule (\ref{rule:action-subsume}) in the proof of Theorem
\ref{thrm:actsafe} goes through by induction and static subsumption,
i.e. Rule (\ref{rule:ana-subsume}). Algorithmically, subsumption should be
the rule of last resort (see Sec. \ref{sec:determinism} for further discussion.)

\subsubsection{Relative Movement}\label{sec:movement}
The rules below define relative movement within Z-types. They should be
self-explanatory:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }{
      \aMove{\dChildn{1}}
    }{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-arr-c2}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }{
      \aMove{\dChildn{2}}
    }{
      \tarr{\htau_1}{\zwsel{\htau_2}}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-parent-arr-left}
  \inferrule{ }{
    \performTyp{
      \tarr{\zwsel{\htau_1}}{\htau_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-parent-arr-right}
  \inferrule{ }{
    \performTyp{
      \tarr{{\htau_1}}{\zwsel{\htau_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\tarr{\htau_1}{\htau_2}}
    }
  }
\end{equation}
\end{subequations}
Two more rules are needed to recurse into the zipper structure. We define
these zipper rules in an action-independent manner in
Sec. \ref{sec:zipper-cases}.

The rules for relative movement within Z-expressions are similarly
straightforward. Movement is type-independent, so we defer to an auxiliary
expression movement judgement in both the analytic and synthetic case:
\begin{subequations}
\begin{equation}
\inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performSyn{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}{\htau}
}
\end{equation}
\begin{equation}
  \inferrule{
  \performMove{\zexp}{\aMove{\delta}}{\zexp'}
}{
  \performAna{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}
}
\end{equation}
\end{subequations}
The expression movement judgement is defined as follows.

\paragraph{Ascription}
\begin{subequations}
  \begin{equation}
    \label{r:movefirstchild-asc}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp : \htau}
    }{
      \aMove{\dChildn{1}}
    }{
      \zwsel{\hexp} : \htau
    }
  }
  \end{equation}
  \begin{equation}
    \label{r:movesecondchild-asc}
    \inferrule{ }{
    \performTyp{
      \zwsel{\hexp : \htau}
    }{
      \aMove{\dChildn{2}}
    }{
      \hexp : \zwsel{\htau}
    }
  }
\end{equation}
\begin{equation}
  \label{r:moveparent}
  \inferrule{ }{
    \performTyp{
      \zwsel{\hexp} : \htau
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}
\begin{equation}\label{rule:move-parent-asc-right}
  \inferrule{ }{
    \performTyp{
      \hexp : \zwsel{\htau}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hexp : \htau}
    }
  }
\end{equation}

\paragraph{Lambda}\vspace{-3px}
\begin{equation}\label{r:movefirstchild-lam}
\inferrule{ }{
  \performMove{
    \zwsel{\hlam{x}{\hexp}}
  }{
    \aMove{\dChildn{1}}
  }{
    \hlam{x}{\zwsel{\hexp}}
  }
}
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hlam{x}{\zwsel{\hexp}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hlam{x}{\hexp}}
    }
  }
\end{equation}
\paragraph{Application}\vspace{-5px}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChildn{1}}
    }{
      \hap{\zwsel{\hexp_1}}{\hexp_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChildn{2}}
    }{
      \hap{\hexp_1}{\zwsel{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hap{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}\label{r:moveparent-ap2}
  \inferrule{ }{
    \performMove{
      \hap{{\hexp_1}}{\zwsel{\hexp_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hap{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}

\paragraph{Plus}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChildn{1}}
    }{
      \hadd{\zwsel{\hexp_1}}{\hexp_2}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }{
      \aMove{\dChildn{2}}
    }{
      \hadd{\hexp_1}{\zwsel{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hadd{\zwsel{\hexp_1}}{\hexp_2}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performMove{
      \hadd{{\hexp_1}}{\zwsel{\hexp_2}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hadd{\hexp_1}{\hexp_2}}
    }
  }
\end{equation}

\paragraph{Non-Empty Hole}
\begin{equation}
\inferrule{ }{
  \performMove{
    \zwsel{\hhole{\hexp}}
  }{
    \aMove{\dChildn{1}}
  }{
    \hhole{\zwsel{\hexp}}
  }
}
\end{equation}
\begin{equation}\label{r:moveparent-hole}
  \inferrule{ }{
    \performMove{
      \hhole{\zwsel{\hexp}}
    }{
      \aMove{\dParent}
    }{
      \zwsel{\hhole{\hexp}}
    }
  }
\end{equation}
Again, additional rules are needed to recurse into the zipper structure,
but we will define these zipper rules in an action-independent manner in
Sec. \ref{sec:zipper-cases}.
\end{subequations}

The rules above are numerous and fairly uninteresting. That makes them
quite hazardous -- we might make a typo or forget a rule absent-mindedly. One check
against this is to establish that movement actions do not
change the cursor erasure, as in Theorem \ref{lemma:movement-erasure}.

\begin{theorem}[Movement Erasure Invariance]\label{lemma:movement-erasure} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\performMove{\ztau}{\aMove{\delta}}{\ztau'}$ then
    $\removeSel{\ztau}=\removeSel{\ztau'}$.

  \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performSyn{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}{\htau'}$
    then $\removeSel{\zexp}=\removeSel{\zexp'}$ and $\htau=\htau'$.

  \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performAna{\hGamma}{\zexp}{\htau}{\aMove{\delta}}{\zexp'}$ then
    $\removeSel{\zexp}=\removeSel{\zexp'}$.

\end{enumerate}
\end{theorem}
\noindent Theorem \ref{lemma:movement-erasure} is useful also in that the
relevant cases of Theorem \ref{thrm:actsafe} are straightforward by its
application.

Another useful check is to establish \emph{reachability}, i.e. that it is
possible, through a sequence of movement actions, to move the cursor from
any position to any other position within a well-typed H-expression.

This requires developing machinery for reasoning about sequences of
actions. There are two possibilities: we can either add a sequencing
action, $\alpha; \alpha$, directly to the syntax of actions, or we can
define a syntax for lists of actions, $\bar{\alpha}$, together with
iterated action judgements. To keep the core of the action semantics small,
we take the latter approach in Figure \ref{fig:multistep}.

A simple auxiliary judgement, $\bar\alpha~\mathsf{movements}$ (not shown) establishes that $\bar\alpha$ consists only of actions of
the form $\aMove{\delta}$.

With these definitions, we can state reachability as follows:

\begin{theorem}[Reachability]\label{thrm:reachability} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\removeSel{\ztau}=\removeSel{\ztau'}$ then there exists some
    $\bar\alpha$ such that $\bar{\alpha}~\mathsf{movements}$ and
    $\performTypI{\ztau}{\bar\alpha}{\ztau'}$.

  \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\removeSel{\zexp}=\removeSel{\zexp'}$ then there exists some
    $\bar{\alpha}$ such that $\bar{\alpha}~\mathsf{movements}$ and
    $\performSynI{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zexp'}{\htau}$.

  \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\removeSel{\zexp}=\removeSel{\zexp'}$ then there exists some
    $\bar{\alpha}$ such that $\bar{\alpha}~\mathsf{movements}$ and
    $\performAnaI{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}$.
  \end{enumerate}
\end{theorem}


The simplest way to prove Theorem \ref{thrm:reachability} is to break it
into two lemmas. Lemma \ref{lemma:reach-up} establishes that you can always
move the cursor to the outermost position in an expression. This serves as
a check on our $\aMove{\dParent}$ rules.
\begin{lemma}[Reach Up]\label{lemma:reach-up} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\removeSel{\ztau}=\htau$ then there exists some $\bar\alpha$
    such that $\bar\alpha~\mathsf{movements}$ and
    $\performTypI{\ztau}{\bar\alpha}{\zwsel{\htau}}$.

  \item If $\hsyn{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$
    then there exists some $\bar\alpha$ such that
    $\bar\alpha~\mathsf{movements}$ and
    $\performSynI{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zwsel{\hexp}}{\htau}$.

  \item If $\hana{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$
    then there exists some $\bar\alpha$ such that
    $\bar\alpha~\mathsf{movements}$ and
    $\performAnaI{\hGamma}{\zexp}{\htau}{\bar\alpha}{\zwsel{\hexp}}$.
  \end{enumerate}
\end{lemma}
Lemma \ref{lemma:reach-down} establishes that you can always move the
cursor from the outermost position to any other position. This serves as a
check on our $\aMove{\dChildnm{n}}$ rules.
\begin{lemma}[Reach Down]\label{lemma:reach-down} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\removeSel{\ztau}=\htau$ then there exists some $\bar\alpha$
    such that $\bar\alpha~\mathsf{movements}$ and
    $\performTypI{\zwsel{\htau}}{\bar\alpha}{\ztau}$.

  \item If $\hsyn{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$
    then there exists some $\bar\alpha$ such that
    $\bar\alpha~\mathsf{movements}$ and
    $\performSynI{\hGamma}{\zwsel{\hexp}}{\htau}{\bar\alpha}{\zexp}{\htau}$.

  \item If $\hana{\hGamma}{\hexp}{\htau}$ and $\removeSel{\zexp}=\hexp$
    then there exists some $\bar\alpha$ such that
    $\bar\alpha~\mathsf{movements}$ and
    $\performAnaI{\hGamma}{\zwsel{\hexp}}{\htau}{\bar\alpha}{\zexp}$.
  \end{enumerate}
\end{lemma}
Theorem \ref{thrm:reachability} follows by straightforward composition of
these two lemmas. The proofs we give of these three theorems in the
mechanization do not produce the shortest sequence of actions to witness
reachability, which would resemble something like a lowest common ancestor
computation. In future versions of Hazelnut that use the produced witnesses
for automatic tool support it may make sense to engineer these proofs
differently; here we are only concerned with whether the theorems are true.

\begin{figure}
$\mathsf{ActionList}$~~$\bar{\alpha} ::= \cdot ~\vert~ \alpha; \bar{\alpha}$\vspace{4px}\\
\fbox{$\performTypI{\ztau}{\bar{\alpha}}{\ztau'}$}

\vspace{-10px}\begin{subequations}
\begin{minipage}{0.35\linewidth}
\begin{equation}
\inferrule{ }{
    \performTypI{\ztau}{\cdot}{\ztau}
}
\end{equation}
\end{minipage}
\begin{minipage}{0.65\linewidth}
\begin{equation}
\inferrule{
  \performTyp{\ztau}{\alpha}{\ztau'}\\
  \performTypI{\ztau'}{\bar{\alpha}}{\ztau''}
}{
  \performTypI{\ztau}{\alpha; \bar{\alpha}}{\ztau''}
}
\end{equation}
\end{minipage}
\end{subequations}

\fbox{$\performSynI{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}{\htau'}$}
\vspace{-10px}

\begin{subequations}\label{rules:iterated-syn}
\hspace{-12px}
\begin{mathpar}
\inferrule{ }{
  \performSynI{\hGamma}{\zexp}{\htau}{\cdot}{\zexp}{\htau}
}
~~~~~~
\inferrule{
  \performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}\\\\
  \performSynI{\hGamma}{\zexp'}{\htau'}{\bar{\alpha}}{\zexp''}{\htau''}
}{
  \performSynI{\hGamma}{\zexp}{\htau}{\alpha; \bar{\alpha}}{\zexp''}{\htau''}
}
~~~~~
\text{(\ref*{rules:iterated-syn}a-b)}
\end{mathpar}
\end{subequations}

\fbox{$\performAna{\hGamma}{\zexp}{\htau}{\bar{\alpha}}{\zexp'}$}
\vspace{-12px}
\begin{subequations}\label{rules:iterated-ana}
\begin{mathpar}
~~~~~~~\inferrule{ }{
  \performAnaI{\hGamma}{\zexp}{\htau}{\cdot}{\zexp}
}
~~~~~~~~~~~~~~
\inferrule{
  \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}\\\\
  \performAnaI{\hGamma}{\zexp'}{\htau}{\bar\alpha}{\zexp''}
}{
  \performAnaI{\hGamma}{\zexp}{\htau}{\alpha; \bar\alpha}{\zexp''}
}
~~~~~~~~~~
\text{(\ref*{rules:iterated-ana}a-b)}
\end{mathpar}
\end{subequations}
\caption{Iterated Action Judgements}
\label{fig:multistep}
\end{figure}
\subsubsection{Construction}\label{sec:construction} The construction
actions, $\aConstruct{\psi}$, are used to construct terms of a shape
indicated by $\psi$ at the cursor.


\paragraph{Types} The $\aConstruct{\farr}$ action constructs an arrow
type. The H-type under the cursor becomes the argument type, and the cursor
is placed on an empty return type hole:
\begin{subequations}
  \begin{equation}
    \label{r:contarr}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aConstruct{\farr}
    }{
      \tarr{\htau}{\zwsel{\tehole}}
    }
  }
\end{equation}
This choice is formally arbitrary -- it would have also been sensible to use the type under the cursor as the return type, for example. Indeed, we could consider defining both of these using different shapes. We avoid this for the sake of simplicity.

The $\aConstruct{\fnum}$ action replaces an empty type hole under the
cursor with the $\tnum$ type:
  \begin{equation}
    \label{r:contnum}
  \inferrule{ }{
    \performTyp{
      \zwsel{\tehole}
    }{
      \aConstruct{\fnum}
    }{
      \zwsel{\tnum}
    }
  }
\end{equation}
\end{subequations}

\begin{subequations}

\paragraph{Ascription} The $\aConstruct{\fasc}$ action operates differently
depending on whether the H-expression under the cursor synthesizes a type
or is being analyzed against a type. In the first case, the synthesized
type appears in the ascription:
\begin{equation}
  \label{r:constructasc}
  \inferrule{ }{
    \performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\hexp : \zwsel{\htau}}{\htau}
  }
\end{equation}
In the second case, the type provided for analysis appears in the ascription:
\begin{equation}
  \inferrule{ }{
    \performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\aConstruct{\fasc}}{\hexp : \zwsel{\htau}}
  }
\end{equation}

\paragraph{Variables} The $\aConstruct{\fvar{x}}$ action places the
variable $x$ into an empty hole. If that hole is being asked to synthesize
a type, then the result synthesizes the hypothesized type:
\begin{equation}
  \label{r:conevar}
  \inferrule{ }{
    \performSyn{\hGamma, x : \htau}{\zwsel{\hehole}}{\tehole}{\aConstruct{\fvar{x}}}{\zwsel{x}}{\htau}
  }
\end{equation}

If the hole is being analyzed against a type that is consistent with the
hypothesized type, then the action semantics goes through the {action
  subsumption rule} described in Sec. \ref{sec:action-subsumption}. If the
hole is being analyzed against a type that is inconsistent with the
hypothesized type, $x$ is placed inside a hole:
\begin{equation}
 \label{r:conevar2}
  \inferrule{
    \tincompat{\htau}{\htau'}
  }{
    \performAna{\hGamma, x : \htau'}{\zwsel{\hehole}}{\htau}{\aConstruct{\fvar{x}}}{\hhole{\zwsel{x}}}
  }
\end{equation}
The rule above featured on Line 16 of Figure \ref{fig:second-example}.

\paragraph{Lambdas} The $\aConstruct{\flam{x}}$ action places a lambda
abstraction binding $x$ into an empty hole. If the empty hole is being
asked to synthesize a type, then the result of the action is a lambda
ascribed the type $\tarr{\tehole}{\tehole}$, with the cursor on the
argument type hole (again, arbitrarily):
\begin{equation}
  \label{r:conelamhole}
  \inferrule{\alpha=\aConstruct{\flam{x}}}{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\alpha}
      {\hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}}
      {\tarr{\tehole}{\tehole}}
  }
\end{equation}
The type ascription is necessary because lambda expressions do not
synthesize a type. (Type-annotated function definitions often
arise as a single syntactic construct in full-scale languages like ML.)

If the empty hole is being analyzed against a type with
matched arrow type, then no ascription is necessary:
\begin{equation}\label{rule:performAna-lam-1}
  \inferrule{
    \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\flam{x}}}
      {\hlam{x}{\zwsel{\hehole}}}
  }
\end{equation}

Finally, if the empty hole is being analyzed against a type that has no
matched arrow type, expressed in the premise as inconsistency with
$\tarr{\tehole}{\tehole}$, then a lambda ascribed the type
$\tarr{\tehole}{\tehole}$ is inserted inside a hole, which defers the type
inconsistency as previously discussed:
\begin{equation}\label{rule:performAna-construct-lam-2}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\flam{x}}}
      {\hhole{
        \hlam{x}{\hehole} : \tarr{\zwsel{\tehole}}{\tehole}
      }}
  }
\end{equation}

\paragraph{Application} The $\aConstruct{\fap}$ action applies the
expression under the cursor. The following rule handles the case where the
synthesized type has matched function type:
\begin{equation}
  \label{r:coneapfn}
  \inferrule{
    \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fap}}
      {\hap{\hexp}{\zwsel{\hehole}}}
      {\htau_2}
  }
\end{equation}
If the expression under the cursor synthesizes a type that is inconsistent
with an arrow type, then we must place that expression inside a hole to
maintain Theorem \ref{sec:holes}:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tarr{\tehole}{\tehole}}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fap}}
      {\hap{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tehole}
  }
\end{equation}

% The $\aConstruct{\farg}$ action instead places the expression under the
% cursor in the argument position of an application form. Because the
% function position is always an empty hole in this situation, we need only a
% single rule:
% \begin{equation}
%   \inferrule{ }{
%     \performSyn
%       {\hGamma}
%       {\zwsel{\hexp}}
%       {\htau}
%       {\aConstruct{\farg}}
%       {\hap{\zwsel{\hehole}}{\hexp}}
%       {\tehole}
%   }
% \end{equation}

\paragraph{Numbers} The $\aConstruct{\fnumlit{n}}$ action replaces an empty
hole with the number expression $\hnum{n}$. If the empty hole is being
asked to synthesize a type, then the rule is straightforward:
\begin{equation}
  \label{r:conenumnum}
  \inferrule{ }{
    \performSyn
      {\hGamma}
      {\zwsel{\hehole}}
      {\tehole}
      {\aConstruct{\fnumlit{n}}}
      {\zwsel{\hnum{n}}}
      {\tnum}
  }
\end{equation}
If the empty hole is being analyzed against a type that is inconsistent
with $\tnum$, then we must place the number expression inside the hole:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hehole}}
      {\htau}
      {\aConstruct{\fnumlit{n}}}
      {\hhole{\zwsel{\hnum{n}}}}
  }
\end{equation}

The $\aConstruct{\fplus}$ action constructs a plus expression with the
expression under the cursor as its first argument (again, arbitrarily.) If that expression
synthesizes a type consistent with $\tnum$, then the rule is
straightforward:
\begin{equation}\label{rule:construct-plus-compat}
  \inferrule{
    \tcompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hexp}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}
Otherwise, we must place that expression inside a hole:
\begin{equation}
  \inferrule{
    \tincompat{\htau}{\tnum}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hexp}}
      {\htau}
      {\aConstruct{\fplus}}
      {\hadd{\hhole{\hexp}}{\zwsel{\hehole}}}
      {\tnum}
  }
\end{equation}

\paragraph{Non-Empty Holes} The final shape is $\fnehole$. This explicitly
places the expression under the cursor inside a hole:
\begin{equation}
\inferrule{ }{
  \performSyn
    {\hGamma}
    {\zwsel{\hexp}}
    {\htau}
    {\aConstruct{\fnehole}}
    {\hhole{\zwsel{\hexp}}}
    {\tehole}
}
\end{equation}\end{subequations}

The $\fnehole$ shape is grayed out in Figure \ref{fig:action-syntax}
because we do not generally expect the programmer to perform it explicitly -- other
actions automatically insert holes when a type inconsistency would
arise.
% Occasionally, it is useful to insert a non-empty hole explicitly
%to avoid multiple automatically inserted non-empty holes that would otherwise arise over a sequence of actions.
The inclusion of this rule
simplifies the statement of the constructability theorem, discussed next.

\paragraph{Constructability}
To check that we have defined ``enough'' construct actions, we need to
establish that we can start from an empty hole and arrive at any well-typed
expression with the cursor on the outside. This simpler statement is
sufficient because Lemma \ref{lemma:reach-down} allows us to then move the
cursor anywhere else inside the constructed term. As with reachability, we
rely on the iterated action judgements defined in Figure
\ref{fig:multistep}.
\begin{theorem}[Constructability]\label{thrm:constructability} ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item For every $\htau$ there exists $\bar\alpha$ such that
    $\performTypI{\zwsel{\tehole}}{\bar\alpha}{\zwsel{\htau}}$.

  \item If $\hsyn{\hGamma}{\hexp}{\htau}$ then there exists $\bar\alpha$
    such
    that: $$\performSynI{\hGamma}{\zwsel{\hhole{}}}{\tehole}{\bar\alpha}{\zwsel{\hexp}}{\htau}$$

  \item If $\hana{\hGamma}{\hexp}{\htau}$ then there exists $\bar\alpha$
    such
    that: $$\performAnaI{\hGamma}{\zwsel{\hhole{}}}{\htau}{\bar\alpha}{\zwsel{\hexp}}$$
  \end{enumerate}
\end{theorem}
Without the $\fnehole$ shape, this theorem as stated would not hold. For example, it is not possible to construct well-typed H-expressions where non-empty holes appear superfluously without the $\fnehole$ shape. Note also that although none of the shapes that we have defined can be dropped without losing this theorem, some construction rules could be dropped. In particular, rules that insert non-empty holes automatically could be dropped because the $\aConstruct{\fnehole}$ action can always be used instead. We included them because we are interested in the mechanics of automatic non-empty hole insertion.

\subsubsection{Deletion} The $\aDel$ action inserts an empty hole at the
cursor, deleting what was there before.

The type action rule for $\aDel$ is self-explanatory:
\begin{equation}
  \inferrule{ }{
    \performTyp{
      \zwsel{\htau}
    }{
      \aDel
    }{
      \zwsel{\tehole}
    }
  }
\end{equation}

Deletion within a Z-expression is similarly straightforward:
\begin{subequations}
\begin{equation}
  \inferrule{ }{
    \performSyn{\hGamma}{\zwsel{\hexp}}{\htau}{\aDel}{\zwsel{\hehole}}{\tehole}
  }
\end{equation}
\begin{equation}
  \inferrule{ }{
    \performAna{\hGamma}{\zwsel{\hexp}}{\htau}{\aDel}{\zwsel{\hehole}}
  }
\end{equation}
\end{subequations}
Unlike the relative movement and construction actions, there is no
``checksum'' theorem for deletion. The rules do not inspect the structure
of the expression in the cursor, so they both match our intuition and will
be correct in any extension of the language without modification.

\subsubsection{Finishing}
The final action we need to consider is $\aFinish$, which finishes the
non-empty hole under the cursor.

If the non-empty hole appears in synthetic position, then it can always be
finished:
\begin{subequations}
  \begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\hexp}{\htau'}
  }{
    \performSyn
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\tehole}
      {\aFinish}
      {\zwsel{\hexp}}
      {\htau'}
  }
\end{equation}

If the non-empty hole appears in analytic position, then it can only be
finished if the type synthesized for the enveloped expression is consistent
with the type that the hole is being analyzed against. This amounts to
analyzing the enveloped expression against the provided type (by
subsumption):
\begin{equation}\label{r:finishana}
  \inferrule{
    \hana{\hGamma}{\hexp}{\htau}
  }{
    \performAna
      {\hGamma}
      {\zwsel{\hhole{\hexp}}}
      {\htau}
      {\aFinish}
      {\zwsel{\hexp}}
  }
\end{equation}
\end{subequations}
Like deletion, there is no need for a ``checksum'' theorem for the
finishing action.


\subsubsection{Zipper Cases}\label{sec:zipper-cases} The rules defined so
far handle the base cases, i.e. the cases where the action has ``reached''
the expression under the cursor. We also need to define the recursive
cases, which propagate the action into the subtree where the cursor
appears, as encoded by the zipper structure. For types, the zipper rules
are straightforward:
\begin{subequations}
\begin{equation}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      \tarr{\ztau}{\htau}
    }{
      \alpha
    }{
      \tarr{\ztau'}{\htau}
    }
  }
\end{equation}
  \begin{equation}
  \inferrule{
    \performTyp{\ztau}{\alpha}{\ztau'}
  }{
    \performTyp{
      \tarr{\htau}{\ztau}
    }{
      \alpha
    }{
      \tarr{\htau}{\ztau'}
    }
  }
\end{equation}
\end{subequations}
For expressions, the zipper rules essentially follow the structure of the
corresponding rules in the statics.

\begin{subequations}
In particular, when the cursor is in the body of a lambda expression, the
zipper case mirrors Rule (\ref{rule:syn-lam}):
\begin{equation}
\inferrule{
  \arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}\\
  \performAna
    {\hGamma, x : \htau_1}
    {\zexp}
    {\htau_2}
    {\alpha}
    {\zexp'}
}{
  \performAna
    {\hGamma}
    {\hlam{x}{\zexp}}
    {\htau}
    {\alpha}
    {\hlam{x}{\zexp'}}
}
\end{equation}


When the cursor is in the function position of an application, the rule
mirrors Rule (\ref{rule:syn-ap}):
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau_2}\\
    \performSyn
      {\hGamma}
      {\zexp}
      {\htau_2}
      {\alpha}
      {\zexp'}
      {\htau_3}\\\\
    \arrmatch{\htau_3}{\tarr{\htau_4}{\htau_5}}\\
    \hana{\hGamma}{\hexp}{\htau_4}
  }{
    \performSyn
      {\hGamma}
      {\hap{\zexp}{\hexp}}
      {\htau_1}
      {\alpha}
      {\hap{\zexp'}{\hexp}}
      {\htau_5}
  }
\end{equation}

The situation is similar when the cursor is in argument position:
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\hexp}{\htau_2}\\
    \arrmatch{\htau_2}{\tarr{\htau_3}{\htau_4}}\\
    \performAna
      {\hGamma}
      {\zexp}
      {\htau_3}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hap{\hexp}{\zexp}}
      {\htau_1}
      {\alpha}
      {\hap{\hexp}{\zexp'}}
      {\htau_4}
  }
\end{equation}

The rules for the addition operator mirror Rule (\ref{rule:syn-plus}):
\begin{equation}
  \inferrule{
    \performAna
      {\hGamma}
      {\zexp}
      {\tnum}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hadd{\zexp}{\hexp}}
      {\tnum}
      {\alpha}
      {\hadd{\zexp'}{\hexp}}
      {\tnum}
  }
\end{equation}
\begin{equation}
  \inferrule{
    \performAna
      {\hGamma}
      {\zexp}
      {\tnum}
      {\alpha}
      {\zexp'}
  }{
    \performSyn
      {\hGamma}
      {\hadd{\hexp}{\zexp}}
      {\tnum}
      {\alpha}
      {\hadd{\hexp}{\zexp'}}
      {\tnum}
  }
\end{equation}

When the cursor is in the expression position of an ascription, we use the
analytic  judgement, mirroring Rule (\ref{rule:syn-asc}):
\begin{equation}
\inferrule{
  \performAna
    {\hGamma}
    {\zexp}
    {\htau}
    {\alpha}
    {\zexp'}
}{
  \performSyn
    {\hGamma}
    {\zexp : \htau}
    {\htau}
    {\alpha}
    {\zexp' : \htau}
    {\htau}
}
\end{equation}

When the cursor is in the type position of an ascription, we must re-check
the ascribed expression because the cursor erasure might have changed (in
practice, one would optimize this check to only occur if the cursor erasure
did change):
\begin{equation}\label{rule:zipper-asc}
\inferrule{
  \performTyp{\ztau}{\alpha}{\ztau'}\\
  \hana{\hGamma}{\hexp}{\removeSel{\ztau'}}
}{
  \performSyn
    {\hGamma}
    {\hexp : \ztau}
    {\removeSel{\ztau}}
    {\alpha}
    {\hexp : \ztau'}
    {\removeSel{\ztau'}}
}
\end{equation}

Finally, if the cursor is inside a non-empty hole, the relevant zipper rule
mirrors Rule (\ref{rule:syn-ehole}):
\begin{equation}
  \inferrule{
    \hsyn{\hGamma}{\removeSel{\zexp}}{\htau}\\
    \performSyn
      {\hGamma}
      {\zexp}
      {\htau}
      {\alpha}
      {\zexp'}
      {\htau'}\\
  }{
    \performSyn
      {\hGamma}
      {\hhole{\zexp}}
      {\tehole}
      {\alpha}
      {\hhole{\zexp'}}
      {\tehole}
  }
\end{equation}

Theorem \ref{thrm:actsafe} directly checks the correctness of these
rules. Moreover, the zipper rules arise ubiquitously in derivations of edit
steps, so the proofs of the other ``check'' theorems, e.g. Reachability and
Constructability, serve as a check that none of these rules have been
missed.
\end{subequations}

\subsection{Determinism}\label{sec:determinism}
A last useful property to consider is \emph{action determinism}, i.e. that
performing an action produces a unique result. The following theorem establishes determinism for type actions:
\begin{theorem}[Type Action Determinism]
\label{thrm:type-actdet} If $\performTyp{\ztau}{\alpha}{\ztau'}$ and
    $\performTyp{\ztau}{\alpha}{\ztau''}$ then $\ztau'=\ztau''$.
\end{theorem}

The corresponding theorem for expression actions would be stated as follows:
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and
    $\performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}{\htau''}$ then
    $\zexp' = \zexp''$ and $\htau' = \htau''$.
  \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ and
    $\performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ then $\zexp' =
    \zexp''$.
  \end{enumerate}

This is not a theorem of the system as described so far. The reason
is somewhat subtle: two construction actions,
$\aConstruct{\fasc}$ and $\aConstruct{\flam{x}}$, behave differently in the
analytic case than they do in the synthetic case. The problem is that both rules can
``fire'' when considering a Z-expression in analytic position due to action subsumption. This is a technically valid but ``morally'' invalid use of action subsumption: subsumption is included in the system to be used as a rule of last resort, i.e. it should only be applied when no other analytic action rule can fire.

There are several possible ways to address this problem. One approach would be to modify the judgement forms to internalize this notion of ``rule of last resort''. This approach is related to focusing from proof theory \cite{Simmons11tr}. However, this approach would substantially complicate our presentation of the system.

The approach that we take leaves the system unchanged. Instead, we define predicates over \emph{derivations} of the expression action judgements that exclude those derivations that apply subsumption prematurely, i.e. when another rule could have been applied. We call such derivations \emph{subsumption-minimal derivations}. We can establish determinism for subsumption-minimal derivations.
\begin{theorem}[Expression Action Determinism] ~
  \begin{enumerate}[itemsep=0px,partopsep=0px,topsep=0px]
  \item If $\hsyn{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\mathcal{D}_1 : \performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}{\htau'}$ and
    $\mathcal{D}_2 : \performSyn{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}{\htau''}$ and $\subminsyn{\mathcal{D}_1}$ and $\subminsyn{\mathcal{D}_2}$ then
    $\zexp' = \zexp''$ and $\htau' = \htau''$.
  \item If $\hana{\hGamma}{\removeSel{\zexp}}{\htau}$ and
    $\mathcal{D}_1 : \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp'}$ and
    $\mathcal{D}_2 : \performAna{\hGamma}{\zexp}{\htau}{\alpha}{\zexp''}$ and $\subminana{\mathcal{D}_1}$ and $\subminana{\mathcal{D}_2}$ then $\zexp' =
    \zexp''$.
  \end{enumerate}
\end{theorem}

The mechanization, discussed next, defines the predicates $\subminsyn{\mathcal{D}}$ and $\subminana{\mathcal{D}}$. In addition, it defines a mapping from
any derivation into a corresponding subsumption-minimal derivation. Implementations of Hazelnut need only implement this subsumption-minimal fragment.
