\def\OPTIONConf{1}%
%\documentclass[12pt]{article}
\documentclass[preprint,9pt]{sigplanconf}
% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ stmaryrd }
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{extarrows}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\definecolor{light-gray}{gray}{0.9}
\usepackage{soul}
\setulcolor{red}
\usepackage{mathpazo}
\usepackage{colortab}
\usepackage{url}
\usepackage{todonotes}
\usepackage{listings}
\lstset{tabsize=2,
basicstyle=\ttfamily\fontsize{8pt}{1em}\selectfont}
\usepackage{microtype}
\sloppy
\def \TirNameStyle #1{\small\rulename{#1}}
\renewcommand{\MathparLineskip}{\lineskiplimit=.3\baselineskip\lineskip=.3\baselineskip plus .2\baselineskip}

\usepackage{joshuadunfield}
\usepackage{llproof}
\usepackage{rulelinks}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newenvironment{proof-sketch}{\noindent{\emph{Proof Sketch.}}}{\qed}
\makeatletter

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

\AtBeginDocument{%
 \abovedisplayskip=2pt
 \abovedisplayshortskip=0pt
 \belowdisplayskip=2pt
 \belowdisplayshortskip=0pt
}

\setlength{\floatsep}{10pt}
\setlength{\textfloatsep}{12pt}

\usepackage[compact]{titlesec}
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{4pt}{2pt}
\titlespacing*{\subsubsection}{0pt}{4pt}{2pt}
\titlespacing*{\paragraph}{0pt}{4pt}{2pt}
\setlength{\skip\footins}{3pt plus 1px minus 5px}

\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink

\usepackage{enumitem}

\usepackage{todonotes}
\usepackage{xcolor}
%\usepackage{adjustbox}

\input{macros}
\begin{document}

\conferenceinfo{-}{-}
\copyrightyear{-}
\copyrightdata{[to be supplied]}

%\titlebanner{}        % These are ignored unless
\preprintfooter{Draft}   % 'preprint' option specified.

\title{Hazelnut: A Bidirectionally Typed \\ Structure Editor
 Calculus}

%\authorinfo{\vspace{-2px}}{}{}
\authorinfo{~}{~}{\vspace{-10px}}
%\authorinfo{Cyrus Omar \and Jonathan Aldrich}
%         {Carnegie Mellon University}
%         {\{comar, aldrich\}@cs.cmu.edu}

\maketitle
\begin{abstract}
% Programmers typically construct and manipulate well-typed expressions  only indirectly, as text that must pass through a parser and type\-checker. Not all text survives this journey. In particular, text that arises transiently, or when the programmer makes a mistake, is often malformed or ill-typed.
% Not all text that arises during the programming process survives the journey through a parser and typechecker. In particular, text that arises transiently during the editing process, or when the programmer has made a mistake, is often malformed or ill-typed.
% Contending with malformed program text or well-formed but meaningless syntax trees is difficult for programmers and their tools alike.

%  \emph{Structure editors} have long promised to alleviate these burdens by exposing only edit actions that  cause sensible changes to the program structure.
% Existing designs for structure editors, however, are complex and somewhat \emph{ad hoc}. They also focus primarily on syntactic well-formedness, so programs can still be left semantically meaningless as they are being constructed.
% Structure editors (e.g. Scratch) eliminate the possibility of syntax errors. 

\emph{Structure editors} allow programmers to edit the tree structure of a program directly. This can have cognitive benefits, particularly for novice and end-user programmers (as evidenced by the popularity of structure editors like Scratch.) It also simplifies matters for tool designers, because they do not need to contend with malformed program text.

This paper defines Hazelnut, a {structure editor} based on a small bidirectionally typed lambda calculus extended with \emph{holes} and a \emph{focus} (\emph{ala} Huet's zipper.) Hazelnut goes one step beyond syntactic well-formedness: it's {edit actions} operate over statically meaningful terms.  
Na\"ively, this prohibition on ill-typed edit states would force the programmer to construct terms in a rigid ``outside-in'' manner. To avoid this problem, the {action semantics} automatically places terms assigned a type that is inconsistent with the expected type {inside} a {hole}. This safely defers the type consistency check until the term inside the hole is \emph{finished}. 

Hazelnut is a foundational type-theoretic account of typed structure editing, rather than an end-user tool itself. To that end, we describe how Hazelnut's rich metatheory, which we have mechanized in Agda, guides the definition of an extension to the calculus. We also discuss various plausible evaluation strategies for terms with holes, and in so doing reveal connections with gradual typing and contextual modal type theory (the Curry-Howard interpretation of contextual modal logic.) Finally, we  discuss how Hazelnut's semantics lends itself to implementation as a functional reactive program. Our reference implementation is written using \lstinline{js_of_ocaml}.

%Formally, Hazelnut is a bidirectionally typed lambda calculus extended with \emph{holes}, a \emph{focus model} (based on Huet's zipper) and an \emph{action model}.
\end{abstract}

%\category{D.3.2}{Programming Languages}{Language Classifications}[Extensible Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\category{F.3.1}{Logics \& Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification Techniques]
%\keywords
%extensible languages; module systems; type abstraction; typed compilation; type-level computation

\section{Introduction}\label{sec:introduction}
\input{intro}

\section{Programming in Hazelnut}\label{sec:example}
\input{example}

\section{Hazelnut, Formally}
\label{sec:hazel}
\input{formally}

\subsection{Mechanization}
\label{sec:mech}\label{sec:mt}
\input{agda}

\clearpage

% \section{Dynamics of Hazelnut}\label{sec:dynamics}

% \subsection{Complete Expressions}
% ... canonical forms and type safety with e complete in it ...

% \subsection{Holes as TODOs}
% ... add an e err and define new type safety ...

% \subsection{Indeterminate Expressions}
% \input{dynamics}

% \clearpage

\section{Extending Hazelnut}\label{sec:extending}
\todo{write this section} Add sum types.

H-expression

Z-expression + Erasure rules

Statics

Movement actions

Construct actions

\input{sumtypes}

\section{Implementation}
\label{sec:impl}
\input{implementation}

\section{Related Work}\label{sec:rw}
%\subsection{Structure Editors}

\todo{TODO: \url{http://research.nii.ac.jp/~hu/pub/hosc07.pdf}}

Structured editing has been recognized as a way to avoid the possibility of syntax errors for decades.  An early example is the
The Cornell Program Synthesizer~\cite{teitelbaum_cornell_1981}, first published in 1981.
The synthesizer generator~\cite{Reps:1984:SG:390010.808247} allows the user to create an attribute-grammar specification that then can be used to generate a structured editor.
CENTAUR~\cite{Borras:1988:CS:64140.65005} produces a language specific environment from a user defined formal specification of a language. Barista \cite{ko_barista:_2006} is a modern take on the same basic concept.%These early systems were developed  of the systems are rooted in the type-theoretic tradition.

Novice programmers have been a common target for structure editors. For example,
GNOME\cite{garlan_gnome:_1984} was developed to teach programming to undergraduates.
Scratch~\cite{Resnick:2009:SP:1592761.1592779} is a structure editor targeted at children ages 8 to 16.
Touchdevelop \cite{tillmann_touchdevelop:_2011} incorporates a structure editor for programming on touch-based devices, and is used to teach high school students.
Alice~\cite{Conway:2000:ALL:332040.332481} is a 3-D programming language with an integrated structure editor for teaching novice CS undergraduate students. These are largely drag-and-drop user interfaces with a limited action model and an unclear semantics.

Not all structure editors are for educational purposes. For example,
mbeddr \cite{voelter_mbeddr:_2012} is an extensible C-based Programming Language and IDE (nominally, for programming embedded systems.)
mbeddr is build on top of the commercial JetBrains MPS framework for constructing structure editors.
Another popular approach is to bring elements of structured editing into a traditional editor.
Codelets \cite{oney_codelets:_2012} uses structured editing to add interactive documentation and examples in an editor.
Our previous work on Graphite~\cite{Omar:2012:ACC:2337223.2337324} allows developers to associate structured editing interfaces called  \emph{palettes} with types. Graphite is integrated into a text-based program editor (Eclipse.)

Agda and Idris are two dependently typed languages that attempt to simulate a structured editor from within a rich text editor (e.g. Emacs.) These systems also have notions of holes and use types to guide the user toward filling these holes. These  systems are also, to our knowledge, not formally well-defined but rather exist only as part of system implementations.

Perhaps the systems most similar in spirit to Hazelnut are Lamdu~\cite{lamdu} and Unison~\cite{unison}. Like Hazelnut, these are both statically typed functional language editors. In both cases, the language is similar to Haskell. In Lamdu, the editor uses structure editing to enable Live Programming, where the code is always being executed as it is being written.

Our work differs from all of these in that we begin with a formal editor calculus and build from there, rather than starting with an implementation and leaving many of the formal details formally unspecified. For example, while Lamdu has many interesting features, there is no theoretical basis presented for their work -- it is a rather large body of Haskell code with an unclear (and indeed, often somewhat perplexing, in our experience) action model. Unison is also a rather large body of Haskell code, though its action model appears superficially more similar to ours. We maintain what we believe to be a stronger action sensibility invariant than Unison (i.e. in Unison, one must construct expressions from the outside-in.) These systems are rich sources of interesting ideas, however -- there is room enough for many different approaches in this (re-)emerging space.

\todo{TODO: cite \url{http://cseweb.ucsd.edu/~lerner/pb.html}}

\todo{TODO: cite} \url{http://delivery.acm.org/10.1145/1060000/1056965/p1557-ko.pdf?ip=73.154.143.34&id=1056965&acc=AUTHOR-IZED&key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2EC2CC0A83071F7605&CFID=780613712&CFTOKEN=33786941&__acm__=1462392463_f29fc98965004c61bfb1291d07756a23}

%Drag-and-drop / for novices: lots of examples, e.g. Alice and others
%
%Contemporary: Lamdu, MPS/Mbeddr, TouchDevelop
%
%Hybrid: Cyrus' active code completion paper

%\subsection{Refactoring Models}
%(Michael, can you fill this section out?)

%\subsection{Formal Editor Models}
%Need to do a search to see what else has been done...

\section{Discussion \& Conclusion}
\label{sec:future}
\todo{revise}This paper presented Hazelnut, a type theoretic structure editor calculus. Our aim is to take a principled approach to its design by formally specifying its semantics, providing strong metatheoretic guarantees, mechanizing its semantics and metatheory in Agda and implementing it using the concepts of  functional reactive programming. As of this submission, we have achieved reasonable confidence in the formal system presented above, and have transitioned our focus toward the mechanization and implementation efforts. By the time of presentation, we anticipate having complete or nearly complete versions of these.

In addition to eliminating malformed edit states, structure editors also promise to increase the speed of development. However, we will not discuss such ``edit costs'' here, because they depend on particular implementation details, e.g. whether a keyboard or a mouse is in use.\todo{integrate this}

By keeping the program in both a structurally and semantically well-defined state at all times, Hazelnut allows users to avoid premature commitment~\cite{green1996usability}.  
By inserting a hole, the user can leave certain parts of the program unfinished, \todo{What is the best word to define this concept?  In progress, unfinished, incomple?} and yet still in a well defined type state. 
This also enables progressive evaluation~\cite{green1996usability}, because unfinished solutions are also are well-defined at all times, thus enabling tools to provide evaluation of unfinished solutions.\todo{integrate this} 

\subsection{Future Work}
Hazelnut is, obviously, a very limited language at its core. So the most obvious avenue for future work is to increase the expressive power of this language. Our plan is to simultaneously maintain a mechanization and implementation (following, for example, Standard ML) as we proceed, ultimately producing the first large-scale, formally verified bidirectionally typed language codesigned with a type-aware editor. It may be that certain language features are unnecessary given a sufficiently advanced type-aware structure editor (e.g. SML's \texttt{open}?), while other features may only be practical with editor support. We intend to use Hazelnut and derivative systems thereof as a platform for rigorously exploring such questions.

There are various aspects of the editor model that we have not yet formalized. For example, our action model does not consider how actions are actually entered using, for example, key combinations or chords. It also did not provide any specific model of how available actions will be determined for presentation to the user. In practice, we would want also to rank available actions in some reasonable manner (perhaps based on usage data gathered from other users or code repositories.)

Another research direction is in exploring how types can be used to control the presentation of expressions in the editor. For example, following our approach in a textual setting on \emph{type-specific languages} (TSLs), it should be possible to have the type that an expression is being analyzed against define alternative display forms and interaction modes \cite{TSLs}.

Finally, we did not consider any aspects of \emph{collaborative programming}, such as a packaging system, a differencing algorithm for use in a source control system, support for multiple simultaneous focii for different users, and so on. These are all interesting avenues for future work.


On the theoretical side, the notion of having one of many possible holes in a term in focus has a very strong intuitive connection
  to the proof theoretic notion of focusing \cite{Simmons11tr}. Beyond just
  the name, both seem to involve, in some sense, a search through the space of possible
  ways to finish a derivation. We intend to explore this connection to see
  if it's coincidental or more meaningful and welcome insights in this regard.

We already discussed a connection to gradual typing \cite{Siek06a}. We hope to explore this connection more thoroughly. In particular, it may be possible to better support exploratory and live programming by allowing even programs with holes in them to execute as long as those holes are only in the type portions, by deferring to the semantics given in work on gradual typing.

It may also be possible to give a dynamics to incomplete expressions. Prior work on staged evaluation suggests that there may be a connection to modal logic, viewing holes as quantifying over all possible terms that may fill them \cite{DBLP:journals/jacm/DaviesP01}. In developing a dynamic semantics, we will also need to handle terms like $\hhole{\hehole}$ and
$\hhole{\hhole{\hexp}}$. In our semantics given here, we eliminated them as they came up in a somewhat \emph{ad hoc} manner. We have not yet
explored an equational theory for terms with holes, but intend to once our
formalization effort is more mature.\todo{fix bib}

\todo{new action form that makes actions extensible given proofs of
admissiblity of a derived form, like prevSib}

\begin{quote}
In any case, these are but steps toward more graphical program-description
systems, for we will not forever stay confined to mere strings of symbols.

--- Marvin Minsky, Turing Award lecture
\end{quote}% We recommend abbrvnat bibliography style.
\clearpage
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{bibliography}
%\softraggedright
%P. Q. Smith, and X. Y. Jones. ...reference text...

\end{document}
