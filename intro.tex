% !TEX root = hazelnut-popl17.tex

Programmers typically construct and manipulate well-typed expressions only
indirectly, by editing text that is first parsed according to a textual
syntax and then typechecked according to a static semantics. This
indirection has practical benefits, to be sure -- text editors and other
text-based tools benefit from decades of development effort -- but it also
introduces some fundamental complexity into the programming process.

First, it requires that programmers learn the subtleties of the textual
syntax (e.g. the precedence of the various forms.) This can be particularly
challenging for novices \cite{Altadmri:2015:MCI:2676723.2677258}.


The fact that not every sequence of characters corresponds to a meaningful program also complicates matters for tool designers. In particular, program editors must contend with meaningless text on a regular basis. In a dataset analyzed by Yoon and Myers consisting of 1460 hours of edit logs, 44.2\% of edit states were syntactically malformed \cite{6883030}. Some additional percentage of edit states were well-formed but ill-typed (the dataset did not contain enough information to determine the exact percentage.)
Some of these meaningless edit states arose because the programmer was in the midst of a sequence of edits that left the edit state transiently meaningless, while others arose because the programmer made a logical mistake. Because the language definitions is silent about these edit states, it is difficult to design useful editor services, e.g. syntax highlighting~\cite{sarkar2015impact}, type-aware code completion~\cite{Mooty:2010:CCC:1915084.1916348,Omar:2012:ACC:2337223.2337324}, and refactoring support \cite{mens2004survey}. Editors must either disable these editor services when they encounter meaningless edit states or develop \emph{ad hoc} heuristics, which can be misleading. %, or because the programmer has made a mistake.

These complications have motivated a long line of research into \emph{structure editors}, i.e. program editors where every edit state is a program structure. % Eliminating text eliminates the possibility of syntax errors.

Most structure editors are \emph{syntactic structure editors}, i.e. the edit state is a syntax tree with \emph{holes} that stand for branches of the tree that have yet to be constructed, and the edit actions are context-free tree transformations. For example, Scratch is a syntactic structure editor that has achieved success as a tool for teaching children how to program \cite{Resnick:2009:SP:1592761.1592779}.

The Scratch language has a trivial static semantics, but researchers have also designed syntactic structure editors for  languages with a non-trivial static semantics. For example, \texttt{mbeddr} is an editor for a C-like language \cite{voelter_mbeddr:_2012}, TouchDevelop is an editor for an object-oriented language \cite{tillmann_touchdevelop:_2011} and Lamdu is an editor for a functional language similar to Haskell \cite{lamdu}. Each of these editors presents an innovative user interface, but the non-trivial type and binding structure of the underlying language complicates its design. The reason is that a syntactic structure editor does not guarantee that every edit state is statically meaningful -- only that it is syntactically well-formed. As in textual program editors, these syntactic structure editors must either disable key editor services when they encounter meaningless edit states or deploy \emph{ad hoc} heuristics.


This paper develops a principled solution to this problem. We introduce Hazelnut,  a \emph{typed structure editor}  based on a bidirectionally typed lambda calculus extended to assign static meaning to expressions and types with {holes}, which we call \textbf{H-expressions} and \textbf{H-types}. Hazelnut's formal \emph{action semantics} maintains the invariant that every edit state is a statically meaningful (i.e. well-typed) H-expression with a single superimposed \emph{cursor}. We call H-expressions and H-types with a cursor \textbf{Z-expressions} and \textbf{Z-types} (so prefixed because our encoding follows Huet's \emph{zipper} pattern \cite{JFP::Huet1997}.) %ctions act relative to the H-expression or H-type under the cursor.% (which need not be a hole.)  %More specifically, actions are context-aware,  acting on an expression whose type is determined by its surroundings (e.g. a function argument), only actions consistent with that type are permitted.

Na\"ively, enforcing an injunction on ill-typed edit states would force programmers to construct programs in a rigid ``outside-in'' manner. For example, the programmer would often need to construct the outer function application form before identifying the intended function. To address this problem, Hazelnut leaves newly constructed expressions \emph{inside} a hole if the expression's type is inconsistent with the expected type. This meaningfully defers the type consistency check until the expression inside the hole is \emph{finished}. In other words, holes appear both at the leaves and at the internal nodes of an H-expression that remain under construction. %In short, Hazelnut is a \emph{bidirectionally typed structure editor calculus}. %Actions act at a programmer-indicate subtree, called the \emph{focus} (which is defined following Huet's zipper pattern.)

% By defining \emph{holes} as a language construct, for both expressions as types, Hazelnut enables type-aware actions that always leave the program in both a structurally and semantically well-defined state.
%In Hazelnut, expressions and types with \emph{holes} have a well-defined static semantics. Edit actions are type-aware and leave the program in both a structurally and semantically well-defined state.



%However, these syntactically correct states can be semantically meaningless (i.e. undefined), because the language definitions generally only give meaning to complete, well-typed terms. (e.g., when a branching element is introduced, the program does not become semantically correct until both branches are complete)
% This makes it difficult for humans and tools to reason about types and binding during the development process, even when using a structure editor.
% Similar to text editors, structure editors also can develop workarounds to try to help users, but these efforts can only extend so far, because of the underlying language definition.
%Some structure editors attempt stuff, but it is not clear what invariants are being maintained (e.g. Unison ; Scratch seems not to allow literals of the wrong type, but variables are not typed.)\todo{revise} %More sophisticated semantic reasoning principles thus remain .






The remainder of this paper is organized as follows:
\begin{itemize}[itemsep=0px,partopsep=2px,topsep=2px]
\item We begin in Sec.
    \ref{sec:example} with two examples of edit sequences to develop the reader's intuitions.
\item We then give a detailed overview of Hazelnut's semantics and metatheory, and our mechanization in the Agda proof assistant, in Sec.  \ref{sec:hazel}.
\item Hazelnut is a {foundational} calculus, i.e. a calculus that language and editor designers are expected to extend with higher level constructs. We extend Hazelnut with simple sum types in Sec.  \ref{sec:extending} to demonstrate how Hazelnut's rich metatheory guides such a development.
\item In Sec.  \ref{sec:impl}, we briefly describe how Hazelnut's action semantics lends itself to efficient implementation as a functional reactive program. Our reference implementation is written using \lstinline{js_of_ocaml} and the OCaml \lstinline{React} library.

% \item However, we consider the space of possible evaluation strategies for incomplete expressions in Section \ref{sec:dynamics}.
% so doing, we discover interesting connections with gradual typing and contextual modal type theory. The former provides an interpretation of type holes, and the latter provides a logical interpretation of expression holes. \todo{revise this one}

\item In Sec.  \ref{sec:rw}, we summarize related work. In particular, much of the technical machinery needed to handle type holes coincides with machinery developed in the study of gradual type systems. Similarly, expression holes can be interpreted as the closures of contextual modal type theory, which, by its correspondence with contextual modal logic, lays logical foundations beneath our work. %This suggests a principled design for an ``edit and resume'' feature.

\item We conclude in Sec.  \ref{sec:future} by summarizing our vision of a principled science of structure editor design rooted in type theory, and suggest a number of future directions.
\end{itemize}
The supplemental material includes 1) a typeset listing of Hazelnut's rules in definitional order; 2) the formalization of Hazelnut in Agda; and 3) our reference implementation of Hazelnut, both in source form and pre-compiled to JavaScript for use in a web browser.
